#!/usr/bin/env node
'use strict';

/** Load Node.js modules. */
var vm = require('vm');

/** Load other modules. */
var _ = require('lodash-compat'),
    minify = require('../lib/minify.js'),
    util = require('../lib/util.js');

/** Module references. */
var fs = util.fs,
    path = util.path;

/** Used as the text displayed for the `--help` option */
var HELP_TEXT = [
  'Usage:',
  '  lodash [commands] [options]',
  '',
  'Commands:',
  '',
  '  compat       Build with support for old & new environments (default)',
  '  modern       Build tailored for newer environments',
  '  strict       Build with ES strict mode enabled',
  '  modularize   Splits lodash into modules',
  '',
  '  include=..   Comma separated function/category names to include in the build',
  '',
  '  minus=..     Comma separated function/category names to remove from the build',
  '',
  '  plus=..      Comma separated function/category names to add to the build',
  '',
  '  category=..  Comma separated categories of functions to include in the build',
  '               (i.e. “array”, “chain”, “collection”, “date”, “function”, “lang”,',
  '               “object”, “number”, “string”, & “utility”)',
  '',
  '  exports=..   Comma separated values of ways to export lodash.',
  '               (i.e. “amd”, “commonjs”, “es”, “global”, “iojs”, “node”, “npm”,',
  '               & “none”)',
  '',
  '  iife=..      Code to replace the IIFE that wraps lodash',
  '               (e.g. `lodash iife="!function(){%output%}()"`)',
  '',
  '  template=..  File path pattern used to match template files to precompile',
  '               (e.g. `lodash template=./*.jst`)',
  '',
  '  settings=..  Template settings used when precompiling templates',
  '               (e.g. `lodash settings="{interpolate:/{{([\\s\\S]+?)}}/g}"`)',
  '',
  '  moduleId=..  The AMD module ID used to export lodash in lodash builds or',
  '               the module ID used to include lodash in compiled templates.',
  '',
  '               Use “none” as the module ID to create compiled templates without',
  '               a dependency on lodash.',
  '',
  '  All commands except `compat` & `modern` may be combined.',
  '',
  '  The `exports` values “es” & “npm” may only be used in conjunction with',
  '  the `modularize` command.',
  '',
  '  The `modularize` command uses the first `exports` values as its module format,',
  '  ignoring subsequent values.',
  '',
  '  Unless specified by `-o` or `--output` all files created are saved to the',
  '  current working directory.',
  '',
  'Options:',
  '',
  '  -c, --stdout       Write output to standard output',
  '  -d, --development  Write only the non-minified development output',
  '  -h, --help         Display help information',
  '  -m, --source-map   Generate a source map using an optional source map URL',
  '  -o, --output       Write output to a given path/filename',
  '  -p, --production   Write only the minified production output',
  '  -s, --silent       Skip status updates normally logged to the console',
  '  -V, --version      Output current version of lodash',
  ''
].join('\n');

/** Used to create regexes that detect single and multi-line comment blocks. */
var commentPattern = '(?: *(?:/\\*[^*]*\\*+(?:[^/][^*]*\\*+)*/|\/\/.*)\\n)*';

/** The current working directory. */
var cwd = process.cwd();

/** Used to indicate whether this file is executed directly from Node.js */
var isBin = module == require.main;

/** Native method references. */
var push = Array.prototype.push;

/** Used to replace string literals with tokens. */
var stringToken = '[[lodash@' + _.VERSION + ' token]]';

/** Used to determine if a variable search should be deep. */
var reDeepVars = /^ *function +runInContext\b/m;

/** Used to detect the JSDoc `@type` tag of "Function". */
var reFuncTag = /^ *\* *@type +Function\b/im;

/** Used to detect if a string is a function snippet. */
var reFuncSnippet = /\b(?:function(?:\s+[$\w]+)?|create[A-Z][a-z]+)\(/;

/** Used to match `getCallback` references. */
var reGetCallback = /\bgetCallback(?:\(\))?/g;

/** Used to match string literals. */
var reStrings = /(["'])(?:(?!\1)[^\n\\]|\\.)*\1/g;

/** Used to match string tokens. */
var reStringTokens = RegExp(_.escapeRegExp(stringToken), 'g');

/** Used to detect if a string is a variable declaration snippet. */
var reVarSnippet = /^\s*var\s+/;

/** Shortcut to the `stdout` object. */
var stdout = process.stdout;

/** Used to map aliases to their real names. */
var aliasToRealMap = createMap({
  'all': 'every',
  'any': 'some',
  'backflow': 'flowRight',
  'collect': 'map',
  'compose': 'flowRight',
  'contains': 'includes',
  'detect': 'find',
  'each': 'forEach',
  'eachRight': 'forEachRight',
  'extend': 'assign',
  'foldl': 'reduce',
  'foldr': 'reduceRight',
  'head': 'first',
  'include': 'includes',
  'inject': 'reduce',
  'iteratee': 'callback',
  'methods': 'functions',
  'object': 'zipObject',
  'reverse': 'wrapperReverse',
  'select': 'filter',
  'tail': 'rest',
  'toJSON': 'wrapperValue',
  'toString': 'wrapperToString',
  'unique': 'uniq',
  'valueOf': 'wrapperValue',
  'value': 'wrapperValue'
});

/** Used to map real names to their aliases. */
var realToAliasMap = createMap({
  'assign': ['extend'],
  'callback': ['iteratee'],
  'every': ['all'],
  'filter': ['select'],
  'find': ['detect'],
  'first': ['head'],
  'flowRight': ['backflow', 'compose'],
  'forEach': ['each'],
  'forEachRight': ['eachRight'],
  'functions': ['methods'],
  'includes': ['contains', 'include'],
  'map': ['collect'],
  'reduce': ['foldl', 'inject'],
  'reduceRight': ['foldr'],
  'rest': ['tail'],
  'some': ['any'],
  'uniq': ['unique'],
  'wrapperReverse': ['reverse'],
  'wrapperToString': ['toString'],
  'wrapperValue': ['toJSON', 'value', 'valueOf'],
  'zipObject': ['object']
});

/** Used to track function dependencies. */
var funcDependencyMap = createMap({

  // Dependencies of variables.
  'metaMap': ['isNative'],

  // Dependencies of lodash properties.
  'support': ['isNative'],
  'templateSettings': ['escape'],

  // Dependencies of the main module.
  'main': ['arrayEach', 'baseForOwn', 'baseMatches', 'baseProperty', 'getCallback', 'isArray', 'lazyClone', 'lazyReverse', 'lazyValue', 'LazyWrapper', 'lodash', 'LodashWrapper', 'mixin', 'thru'],

  // Dependencies of lodash methods.
  'after': ['isFunction'],
  'ary': ['createWrapper', 'isIterateeCall'],
  'assign': ['baseAssign', 'createAssigner'],
  'at': ['baseAt', 'baseFlatten', 'isLength', 'toIterable'],
  'attempt': ['isError'],
  'before': ['isFunction'],
  'bind': [ 'baseSlice', 'createWrapper', 'lodash', 'replaceHolders'],
  'bindAll': ['baseBindAll', 'baseFlatten', 'functions'],
  'bindKey': [ 'baseSlice', 'createWrapper', 'lodash', 'replaceHolders'],
  'callback': ['baseCallback', 'isIterateeCall', 'isObjectLike', 'matches'],
  'camelCase': ['createCompounder'],
  'capitalize': ['baseToString'],
  'chain': ['lodash'],
  'chunk': ['baseSlice', 'isIterateeCall'],
  'clone': ['baseClone', 'bindCallback', 'isIterateeCall'],
  'cloneDeep': ['baseClone', 'bindCallback'],
  'compact': [],
  'constant': [],
  'countBy': ['createAggregator'],
  'create': ['baseCopy', 'baseCreate', 'isIterateeCall', 'keys'],
  'curry': ['createWrapper', 'isIterateeCall', 'lodash'],
  'curryRight': ['createWrapper', 'isIterateeCall', 'lodash'],
  'debounce': ['isFunction', 'isObject', 'now'],
  'deburr': ['baseToString', 'deburrLetter'],
  'defaults': ['arrayCopy', 'assign', 'assignDefaults'],
  'defer': ['baseDelay'],
  'delay': ['baseDelay'],
  'difference': ['baseDifference', 'baseFlatten', 'isArguments', 'isArray'],
  'drop': ['baseSlice', 'isIterateeCall'],
  'dropRight': ['baseSlice', 'isIterateeCall'],
  'dropRightWhile': ['baseSlice', 'getCallback'],
  'dropWhile': ['baseSlice', 'getCallback'],
  'endsWith': ['baseToString'],
  'escape': ['baseToString', 'escapeHtmlChar'],
  'escapeRegExp': ['baseToString'],
  'every': ['arrayEvery', 'baseEvery', 'getCallback', 'isArray'],
  'filter': ['arrayFilter', 'baseFilter', 'getCallback', 'isArray'],
  'find': ['baseEach', 'baseFind', 'getCallback', 'findIndex', 'isArray'],
  'findIndex': ['getCallback'],
  'findLastIndex': ['getCallback'],
  'findKey': ['baseFind', 'baseForOwn', 'getCallback'],
  'findLast': ['baseEachRight', 'baseFind', 'getCallback'],
  'findLastKey': ['baseFind', 'baseForOwnRight', 'getCallback'],
  'findWhere': ['baseMatches', 'find'],
  'first': [],
  'flatten': ['baseFlatten', 'isIterateeCall'],
  'flattenDeep': ['baseFlatten'],
  'flow': ['arrayEvery', 'isFunction'],
  'flowRight': ['arrayEvery', 'isFunction'],
  'forEach': ['arrayEach', 'baseEach', 'bindCallback', 'isArray'],
  'forEachRight': ['arrayEachRight', 'baseEachRight', 'bindCallback', 'isArray'],
  'forIn': ['baseFor', 'bindCallback','keysIn'],
  'forInRight': ['baseForRight', 'bindCallback', 'keysIn'],
  'forOwn': ['baseForOwn', 'bindCallback'],
  'forOwnRight': ['baseForRight', 'bindCallback', 'keys'],
  'functions': ['baseFunctions', 'keysIn'],
  'groupBy': ['createAggregator'],
  'has': [],
  'identity': [],
  'includes': ['getIndexOf', 'isArray', 'isLength', 'isString', 'values'],
  'indexBy': ['createAggregator'],
  'indexOf': ['baseIndexOf', 'binaryIndex'],
  'initial': ['dropRight'],
  'intersection': ['cacheIndexOf', 'createCache', 'getIndexOf', 'isArguments', 'isArray'],
  'invert': ['isIterateeCall', 'keys'],
  'invoke': ['baseInvoke', 'baseSlice'],
  'isArguments': ['isLength', 'isObjectLike'],
  'isArray': ['isLength', 'isNative', 'isObjectLike'],
  'isBoolean': ['isObjectLike'],
  'isDate': ['isObjectLike'],
  'isElement': ['isHostObject', 'isObjectLike', 'isPlainObject'],
  'isEmpty': ['isArguments', 'isArray', 'isFunction', 'isLength', 'isObjectLike', 'isString', 'keys'],
  'isEqual': ['baseIsEqual', 'bindCallback', 'isStrictComparable'],
  'isError': ['isObjectLike'],
  'isFinite': ['isNative'],
  'isFunction': ['isNative'],
  'isMatch': ['baseIsMatch', 'bindCallback', 'isStrictComparable', 'keys'],
  'isNaN': ['isNumber'],
  'isNative': ['escapeRegExp', 'isHostObject', 'isObjectLike'],
  'isNull': [],
  'isNumber': ['isObjectLike'],
  'isObject': [],
  'isPlainObject': ['isArguments', 'isNative', 'shimIsPlainObject'],
  'isRegExp': ['isObject'],
  'isString': ['isObjectLike'],
  'isUndefined': [],
  'kebabCase': ['createCompounder'],
  'keys': ['isLength', 'isObject', 'isNative', 'shimKeys'],
  'keysIn': ['arrayEach', 'isArguments', 'isArray', 'isIndex', 'isLength', 'isObject', 'isString'],
  'last': [],
  'lastIndexOf': ['indexOfNaN', 'binaryIndex'],
  'lodash': ['arrayCopy', 'isArray', 'isObjectLike', 'LodashWrapper'],
  'map': ['arrayMap', 'baseMap', 'getCallback', 'isArray'],
  'mapValues': ['baseForOwn', 'getCallback'],
  'matches': ['baseClone', 'baseMatches'],
  'max': ['arrayMax', 'createExtremum'],
  'memoize': ['isFunction', 'MapCache'],
  'merge': ['baseMerge', 'createAssigner'],
  'min': ['arrayMin', 'createExtremum'],
  'mixin': ['arrayCopy', 'baseFunctions', 'isFunction', 'isObject', 'keys', 'lodash'],
  'negate': ['isFunction'],
  'noConflict': [],
  'noop': [],
  'now': ['isNative'],
  'omit': ['arrayMap', 'baseDifference', 'baseFlatten', 'bindCallback', 'keysIn', 'pickByArray', 'pickByCallback'],
  'once': ['before'],
  'pad': ['baseToString', 'createPad'],
  'padLeft': ['baseToString', 'createPad'],
  'padRight': ['baseToString', 'createPad'],
  'pairs': ['keys'],
  'parseInt': ['isIterateeCall', 'trim'],
  'partial': ['baseSlice', 'createWrapper', 'lodash', 'replaceHolders'],
  'partialRight': ['baseSlice', 'createWrapper', 'lodash', 'replaceHolders'],
  'partition': ['createAggregator'],
  'pick': ['baseFlatten', 'bindCallback', 'pickByArray', 'pickByCallback'],
  'pluck': ['baseProperty', 'map'],
  'property': ['baseProperty'],
  'propertyOf': [],
  'pull': ['getIndexOf'],
  'pullAt': ['baseFlatten', 'basePullAt'],
  'random': ['baseRandom', 'isIterateeCall'],
  'range': ['isIterateeCall'],
  'rearg': ['baseFlatten', 'createWrapper'],
  'reduce': ['arrayReduce', 'baseEach', 'baseReduce', 'getCallback', 'isArray'],
  'reduceRight': ['arrayReduceRight', 'baseEachRight', 'baseReduce', 'getCallback', 'isArray'],
  'reject': ['arrayFilter', 'baseFilter', 'getCallback', 'isArray'],
  'remove': ['getCallback'],
  'repeat': ['baseToString'],
  'rest': ['drop'],
  'result': ['isFunction'],
  'runInContext': ['defaults', 'pick'],
  'sample': ['baseRandom', 'isIterateeCall', 'shuffle', 'toIterable'],
  'shuffle': ['baseRandom', 'toIterable'],
  'size': ['isLength', 'keys'],
  'slice': ['baseSlice', 'isIterateeCall'],
  'snakeCase': ['createCompounder'],
  'some': ['arraySome', 'baseSome', 'getCallback', 'isArray'],
  'sortBy': ['baseEach', 'baseSortBy', 'compareAscending', 'getCallback', 'isIterateeCall', 'isLength'],
  'sortByAll': ['baseEach', 'baseFlatten', 'baseSortBy', 'compareMultipleAscending', 'isIterateeCall', 'isLength'],
  'sortedIndex': ['baseCallback', 'binaryIndex', 'binaryIndexBy', 'getCallback'],
  'sortedLastIndex': ['baseCallback', 'binaryIndex', 'binaryIndexBy', 'getCallback'],
  'startCase': ['createCompounder'],
  'startsWith': ['baseToString'],
  'take': ['baseSlice', 'isIterateeCall'],
  'takeRight': ['baseSlice', 'isIterateeCall'],
  'takeRightWhile': ['baseSlice', 'getCallback'],
  'takeWhile': ['baseSlice', 'getCallback'],
  'tap': [],
  'template': ['assignOwnDefaults', 'attempt', 'baseAssign', 'baseToString', 'baseValues', 'escapeStringChar', 'isError', 'isIterateeCall', 'keys'],
  'throttle': ['debounce', 'isFunction', 'isObject'],
  'thru': [],
  'times': ['bindCallback'],
  'toArray': ['arrayCopy', 'isLength', 'isString', 'values'],
  'toPlainObject': ['baseCopy', 'keysIn'],
  'transform': ['arrayEach', 'baseCreate', 'baseForOwn', 'getCallback', 'isArray', 'isObject', 'isTypedArray'],
  'trim': ['baseToString', 'charsLeftIndex', 'charsRightIndex', 'isIterateeCall', 'trimmedLeftIndex', 'trimmedRightIndex'],
  'trimLeft': ['baseToString', 'charsLeftIndex', 'isIterateeCall', 'trimmedLeftIndex'],
  'trimRight': ['baseToString', 'charsRightIndex', 'isIterateeCall', 'trimmedRightIndex'],
  'trunc': ['baseToString', 'isIterateeCall', 'isObject', 'isRegExp'],
  'unescape': ['baseToString', 'unescapeHtmlChar'],
  'union': ['baseFlatten', 'baseUniq'],
  'uniq': ['baseCallback', 'baseUniq', 'getCallback', 'getIndexOf', 'isIterateeCall', 'sortedUniq'],
  'uniqueId': ['baseToString'],
  'unzip': ['arrayMap', 'arrayMax', 'baseProperty'],
  'values': ['baseValues', 'keys'],
  'valuesIn': ['baseValues', 'keysIn'],
  'where': ['baseMatches', 'filter'],
  'without': ['baseDifference', 'baseSlice'],
  'words': ['baseToString', 'isIterateeCall'],
  'wrap': ['createWrapper', 'identity'],
  'xor': ['baseDifference', 'baseUniq', 'isArguments', 'isArray'],
  'zip': ['unzip'],
  'zipObject': ['isArray'],

  // Dependencies of Lazy wrapper functions.
  'LazyWrapper': [],
  'lazyClone': ['arrayCopy', 'LazyWrapper'],
  'lazyReverse': ['LazyWrapper'],
  'lazyValue': ['baseWrapperValue', 'getView', 'isArray'],

  // Dependencies of lodash wrapper functions.
  'LodashWrapper': [],
  'wrapperChain': ['chain'],
  'wrapperReverse': ['LazyWrapper', 'LodashWrapper', 'thru'],
  'wrapperToString': [],
  'wrapperValue': ['baseWrapperValue'],

  // Dependencies of `Map` cache functions.
  'MapCache': ['mapDelete', 'mapGet', 'mapHas', 'mapSet'],
  'mapDelete': [],
  'mapGet': [],
  'mapHas': [],
  'mapSet': [],

  // Dependencies of `Set` cache functions.
  'SetCache': ['cachePush', 'isNative'],
  'cacheIndexOf': ['isObject'],
  'cachePush': ['isObject'],
  'createCache': ['constant', 'isNative', 'SetCache'],

  // Dependencies of private functions.
  'arrayCopy': [],
  'arrayEach': [],
  'arrayEachRight': [],
  'arrayEvery': [],
  'arrayFilter': [],
  'arrayMap': [],
  'arrayMax': [],
  'arrayMin': [],
  'arrayReduce': [],
  'arrayReduceRight': [],
  'arraySome': [],
  'assignDefaults': [],
  'assignOwnDefaults': [],
  'baseAssign': ['baseCopy', 'keys'],
  'baseAt': ['isIndex', 'isLength'],
  'baseBindAll': ['createWrapper'],
  'baseCallback': ['baseProperty', 'baseMatches', 'bindCallback', 'identity', 'isBindable'],
  'baseClone': ['arrayCopy', 'arrayEach', 'baseCopy', 'baseForOwn', 'initCloneArray', 'initCloneByTag', 'initCloneObject', 'isArray', 'isHostObject', 'isObject', 'keys'],
  'baseCompareAscending': [],
  'baseCopy': [],
  'baseCreate': ['isObject'],
  'baseDelay': ['baseSlice', 'isFunction'],
  'baseDifference': ['cacheIndexOf', 'createCache', 'getIndexOf'],
  'baseEach': ['baseForOwn', 'isLength', 'toObject'],
  'baseEachRight': ['baseForOwnRight', 'isLength', 'toObject'],
  'baseEvery': ['baseEach'],
  'baseFilter': ['baseEach'],
  'baseFind': [],
  'baseFlatten': ['isArguments', 'isArray', 'isLength', 'isObjectLike'],
  'baseFor': ['toObject'],
  'baseForIn': ['baseFor', 'keysIn'],
  'baseForOwn': ['baseFor', 'keys'],
  'baseForOwnRight': ['baseForRight', 'keys'],
  'baseForRight': ['toObject'],
  'baseFunctions': ['isFunction'],
  'baseIndexOf': ['indexOfNaN'],
  'baseInvoke': ['baseEach', 'isLength'],
  'baseIsEqual': ['baseIsEqualDeep'],
  'baseIsEqualDeep': ['equalArrays', 'equalByTag', 'equalObjects', 'isArray', 'isHostObject', 'isTypedArray'],
  'baseIsMatch': ['baseIsEqual'],
  'baseMap': ['baseEach'],
  'baseMatches': ['baseIsMatch', 'isStrictComparable', 'keys'],
  'baseMerge': ['arrayEach', 'baseForOwn', 'baseMergeDeep', 'isArray', 'isLength', 'isObjectLike', 'isTypedArray'],
  'baseMergeDeep': ['arrayCopy', 'isArguments', 'isArray', 'isLength', 'isPlainObject', 'isTypedArray', 'toPlainObject'],
  'baseProperty': [],
  'basePullAt': ['baseAt', 'baseCompareAscending', 'isIndex'],
  'baseRandom': [],
  'baseReduce': [],
  'baseSetData': ['identity'],
  'baseSlice': [],
  'baseSome': ['baseEach'],
  'baseSortBy': [],
  'baseToString': [],
  'baseUniq': ['cacheIndexOf', 'createCache', 'getIndexOf'],
  'baseValues': [],
  'baseWrapperValue': ['LazyWrapper'],
  'binaryIndex': ['binaryIndexBy', 'identity'],
  'binaryIndexBy': [],
  'bindCallback': ['identity'],
  'bufferClone': ['constant', 'isNative'],
  'charAtCallback': [],
  'charsLeftIndex': [],
  'charsRightIndex': [],
  'compareAscending': ['baseCompareAscending'],
  'compareMultipleAscending': ['baseCompareAscending'],
  'composeArgs': [],
  'composeArgsRight': [],
  'createAggregator': ['baseEach', 'getCallback', 'isArray'],
  'createAssigner': ['bindCallback', 'isIterateeCall'],
  'createBindWrapper': ['createCtorWrapper'],
  'createCompounder': ['deburr', 'words'],
  'createCtorWrapper': ['baseCreate', 'isObject'],
  'createExtremum': ['baseCallback', 'charAtCallback', 'extremumBy', 'getCallback', 'isArray', 'isIterateeCall', 'isString', 'toIterable'],
  'createHybridWrapper': ['arrayCopy', 'composeArgs', 'composeArgsRight', 'createCtorWrapper', 'reorder', 'replaceHolders'],
  'createPad': ['repeat'],
  'createPartialWrapper': ['createCtorWrapper'],
  'createWrapper': ['baseSetData', 'createBindWrapper', 'createHybridWrapper', 'createPartialWrapper', 'getData', 'isFunction', 'mergeData', 'setData'],
  'deburrLetter': [],
  'escapeHtmlChar': [],
  'escapeStringChar': [],
  'equalArrays': [],
  'equalByTag': [],
  'equalObjects': ['keys'],
  'extremumBy': ['baseEach'],
  'getCallback': ['baseCallback', 'callback'],
  'getData': ['noop'],
  'getIndexOf': ['baseIndexOf', 'indexOf'],
  'getView': [],
  'indexOfNaN': [],
  'initCloneArray': [],
  'initCloneByTag': ['bufferClone'],
  'initCloneObject': [],
  'isBindable': ['baseSetData', 'isNative'],
  'isHostObject': [],
  'isIndex': [],
  'isIterateeCall': ['isIndex', 'isLength', 'isObject'],
  'isLength': [],
  'isObjectLike': [],
  'isSpace': [],
  'isStrictComparable': ['isObject'],
  'isTypedArray': ['isLength', 'isObjectLike'],
  'mergeData': ['arrayCopy', 'composeArgs', 'composeArgsRight', 'replaceHolders'],
  'pickByArray': ['toObject'],
  'pickByCallback': ['baseForIn'],
  'reorder': ['arrayCopy', 'isIndex'],
  'replaceHolders': [],
  'setData': ['baseSetData', 'now'],
  'shimIsPlainObject': ['baseForIn', 'isArguments', 'isHostObject', 'isObjectLike'],
  'shimKeys': ['isArguments', 'isArray', 'isIndex', 'isLength', 'isString', 'keysIn'],
  'sortedUniq': [],
  'toIterable': ['isLength', 'isObject', 'isString', 'values'],
  'toObject': ['isObject', 'isString'],
  'trimmedLeftIndex': ['isSpace'],
  'trimmedRightIndex': ['isSpace'],
  'unescapeHtmlChar': []
});

/** Used to track lodash object dependencies of identifiers. */
var objDependencyMap = createMap({
  'isArguments': ['support'],
  'isBindable': ['support'],
  'isElement': ['support'],
  'isPlainObject': ['support'],
  'keys': ['support'],
  'keysIn': ['support'],
  'main': ['support'],
  'shimIsPlainObject': ['support'],
  'shimKeys': ['support'],
  'template': ['templateSettings'],
  'toArray': ['support'],
  'toIterable': ['support'],
  'toObject': ['support']
});

/** Used to track variable dependencies of identifiers. */
var varDependencyMap = createMap({
  'after': ['root'],
  'baseCreate': ['root'],
  'baseSetData': ['metaMap'],
  'bufferClone': ['root'],
  'createCache': ['root'],
  'createPad': ['root'],
  'getData': ['metaMap'],
  'initCloneByTag': ['root'],
  'isFinite': ['root'],
  'isFunction': ['root'],
  'metaMap': ['root'],
  'pad': ['root'],
  'parseInt': ['root'],
  'repeat': ['root'],
  'SetCache': ['root'],
  'support': ['root'],
  'template': ['reInterpolate'],
  'templateSettings': ['reEscape', 'reEvaluate', 'reInterpolate'],
  'times': ['root']
});

/** Used to track the category of identifiers. */
var categoryMap = createMap({
  'Array': [
    'chunk',
    'compact',
    'difference',
    'drop',
    'dropRight',
    'dropRightWhile',
    'dropWhile',
    'findIndex',
    'findLastIndex',
    'first',
    'flatten',
    'flattenDeep',
    'indexOf',
    'initial',
    'intersection',
    'last',
    'lastIndexOf',
    'pull',
    'pullAt',
    'remove',
    'rest',
    'slice',
    'sortedIndex',
    'sortedLastIndex',
    'take',
    'takeRight',
    'takeRightWhile',
    'takeWhile',
    'union',
    'uniq',
    'unzip',
    'without',
    'xor',
    'zip',
    'zipObject'
  ],
  'Chain': [
    'chain',
    'lodash',
    'tap',
    'thru',
    'wrapperChain',
    'wrapperReverse',
    'wrapperToString',
    'wrapperValue'
  ],
  'Collection': [
    'at',
    'countBy',
    'every',
    'filter',
    'find',
    'findLast',
    'findWhere',
    'forEach',
    'forEachRight',
    'groupBy',
    'includes',
    'indexBy',
    'invoke',
    'map',
    'max',
    'min',
    'partition',
    'pluck',
    'reduce',
    'reduceRight',
    'reject',
    'sample',
    'shuffle',
    'size',
    'some',
    'sortBy',
    'sortByAll',
    'where'
  ],
  'Date': [
    'now'
  ],
  'Function': [
    'after',
    'ary',
    'before',
    'bind',
    'bindAll',
    'bindKey',
    'curry',
    'curryRight',
    'debounce',
    'defer',
    'delay',
    'flow',
    'flowRight',
    'memoize',
    'negate',
    'once',
    'partial',
    'partialRight',
    'rearg',
    'throttle',
    'wrap'
  ],
  'Lang': [
    'clone',
    'cloneDeep',
    'isArguments',
    'isArray',
    'isBoolean',
    'isDate',
    'isElement',
    'isEmpty',
    'isEqual',
    'isError',
    'isFinite',
    'isFunction',
    'isMatch',
    'isNaN',
    'isNative',
    'isNull',
    'isNumber',
    'isObject',
    'isPlainObject',
    'isRegExp',
    'isString',
    'isTypedArray',
    'isUndefined',
    'toArray',
    'toPlainObject'
  ],
  'Number': [
    'random'
  ],
  'Object': [
    'assign',
    'create',
    'defaults',
    'findKey',
    'findLastKey',
    'forIn',
    'forInRight',
    'forOwn',
    'forOwnRight',
    'functions',
    'has',
    'invert',
    'keys',
    'keysIn',
    'mapValues',
    'merge',
    'omit',
    'pairs',
    'pick',
    'result',
    'transform',
    'values',
    'valuesIn'
  ],
  'String': [
    'camelCase',
    'capitalize',
    'deburr',
    'endsWith',
    'escape',
    'escapeRegExp',
    'kebabCase',
    'pad',
    'padLeft',
    'padRight',
    'parseInt',
    'repeat',
    'snakeCase',
    'startCase',
    'startsWith',
    'template',
    'templateSettings',
    'trim',
    'trimLeft',
    'trimRight',
    'trunc',
    'unescape',
    'words'
  ],
  'Utility': [
    'attempt',
    'callback',
    'constant',
    'identity',
    'matches',
    'mixin',
    'noConflict',
    'noop',
    'property',
    'propertyOf',
    'range',
    'runInContext',
    'times',
    'uniqueId'
  ]
});

/** Used to map category aliases to their real names. */
var aliasToCategoryMap = createMap({
  'Arrays': 'Array',
  'Chaining': 'Chain',
  'Collections': 'Collection',
  'Dates': 'Date',
  'Functions': 'Function',
  'Langs': 'Lang',
  'Numbers': 'Number',
  'Objects': 'Object',
  'Strings': 'String',
  'Utilities': 'Utility'
});

/* Used to map categories to their dependency name. */
var categoryToDepNameMap = createMap({
  'Array': 'array',
  'Chain': 'chain',
  'Collection': 'collection',
  'Date': 'date',
  'Function': 'func',
  'Lang': 'lang',
  'Number': 'number',
  'Object': 'object',
  'String': 'string',
  'Utility': 'utility'
});

/* Used to force referencing identifers by their alias. */
var forceAliasMap = createMap({
  'wrapperReverse': 'reverse',
  'wrapperToString': 'toString',
  'wrapperValue': 'value'
});

/* Used to force inlining of uninlinables per identifier. */
var forceInlineMap = createMap({
  'baseEach': ['baseFor'],
  'baseCallback': ['baseIsMatch', 'baseMatches', 'baseProperty'],
  'isArray': ['baseToString', 'isNative'],
  'isFunction': ['baseToString', 'isNative'],
  'isNative': ['baseToString'],
  'keys': ['keysIn'],
  'template': ['baseAssign']
});

/* Used to designate dependencies at the top level. */
var topLevel = createMap({
  'main': true,
  'support': true
});

/** List of all object property dependencies. */
var objDependencies = _.uniq(_.transform(objDependencyMap, _.bind(push.apply, push), [])).sort();

/** List of all variable dependencies. */
var varDependencies = _.uniq(_.transform(varDependencyMap, _.bind(push.apply, push), [])).sort();

/** List of all function categories. */
var allCategories = _.keys(categoryMap).sort();

/** List of all functions. */
var allFuncs = _.filter(_.difference(_.keys(funcDependencyMap), objDependencies, varDependencies).sort(), function(key) {
  var type = typeof _.prototype[key];
  return type == 'function' || type == 'undefined';
});

/** List of lodash functions. */
var lodashFuncs = _.intersection(allFuncs, _.union(
  _.functions(_),
  _.functions(_.prototype), [
  'main',
  'wrapperChain',
  'wrapperReverse',
  'wrapperToString',
  'wrapperValue'
]));

/** List of the default ways to export the `lodash` function. */
var defaultExports = [
  'amd',
  'commonjs',
  'global',
  'iojs',
  'node'
];

/** List of variables with complex assignments. */
var complexVars = [
  'cloneableTags',
  'contextProps',
  'ctorByTag',
  'freeGlobal',
  'nonEnumProps',
  'reWords',
  'shadowProps',
  'support',
  'typedArrayTags',
  'whitespace'
];

/** List of functions that support argument placeholders. */
var placeholderFuncs = [
  'bind',
  'bindKey',
  'curry',
  'curryRight',
  'partial',
  'partialRight'
];

/** List of uninlinable dependencies. */
var uninlinables = _.union(
  _.without(lodashFuncs,
    'attempt',
    'constant',
    'drop',
    'dropRight',
    'escapeRegExp',
    'filter',
    'identity',
    'isObject',
    'matches',
    'noop',
    'now',
    'pluck',
    'property',
    'values'
  ),
  _.keys(_.support),
  _.keys(_.templateSettings), [
  'arrayCopy',
  'arrayEach',
  'arrayEvery',
  'arrayFilter',
  'arrayMap',
  'arrayMax',
  'arrayMin',
  'baseAssign',
  'baseAt',
  'baseCallback',
  'baseClone',
  'baseCompareAscending',
  'baseCopy',
  'baseCreate',
  'baseDelay',
  'baseDifference',
  'baseEach',
  'baseEachRight',
  'baseFilter',
  'baseFind',
  'baseFlatten',
  'baseFor',
  'baseForRight',
  'baseFunctions',
  'baseIndexOf',
  'baseIsEqual',
  'baseIsMatch',
  'baseMatches',
  'baseProperty',
  'baseRandom',
  'baseReduce',
  'baseSlice',
  'baseSortBy',
  'baseToString',
  'baseUniq',
  'baseValues',
  'binaryIndex',
  'binaryIndexBy',
  'bindCallback',
  'cacheIndexOf',
  'charsLeftIndex',
  'charsRightIndex',
  'createAggregator',
  'createAssigner',
  'createCache',
  'createCompounder',
  'createExtremum',
  'createPad',
  'createWrapper',
  'isIterateeCall',
  'pickByArray',
  'pickByCallback',
  'reInterpolate',
  'reEscape',
  'reEvaluate',
  'replaceHolders',
  'templateSettings',
  'toIterable',
  'trimmedLeftIndex',
  'trimmedRightIndex'
]).sort();

/*----------------------------------------------------------------------------*/

/**
 * Adds build `commands` to the copyright/license header of `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @param {Array} [commands=[]] An array of commands.
 * @returns {string} Returns the modified source.
 */
function addCommandsToHeader(source, commands) {
  source = source == null ? '' : String(source);

  return source.replace(getHeader(source), function(header) {
    // Add quotes to commands with spaces or equals signs.
    commands = _.map(commands, function(command) {
      var separator = /[= ]/.exec(command);
      if (separator) {
        separator = separator[0];
        var pair = command.split(separator);
        command = pair[0] + separator + '"' + pair[1] + '"';
      }
      // Escape newlines, carriage returns, multi-line comment end tokens.
      return command
        .replace(/\n/g, '\\n')
        .replace(/\r/g, '\\r')
        .replace(/\*\//g, '*\\/');
    });

    // Remove any existing custom build information.
    header = header
      .replace(' (Custom Build)', '')
      .replace(/^ *\* *Build:.+\n/m, '');

    // Add build commands to copyright/license header.
    return header.replace(/(\/\**\n)( \*)( *@license[\s*]+)?( *lodash [.$\w\-]+)(.*)/, function() {
      return (
        arguments[1] +
        arguments[2] +
        (arguments[3] || '') +
        arguments[4] + ' (Custom Build)' + arguments[5] + '\n' +
        arguments[2] + ' Build: `lodash ' + commands.join(' ') + '`'
      );
    });
  });
}

/**
 * Creates modules based on the provided build state.
 *
 * @private
 * @param {Object} state The build state object.
 * @param {Function} [onComplete] The function called when all module builds
 *  are completed.
 */
function buildModule(state, onComplete) {
  var buildFuncs = state.buildFuncs,
      funcDepMap = state.funcDepMap,
      includeFuncs = state.includeFuncs,
      includeObjs = state.includeObjs,
      includeVars = state.includeVars,
      isAMD = state.isAMD,
      isCommonJS = state.isCommonJS,
      isES = state.isES,
      isNpm = state.isNpm,
      isSilent = state.isSilent,
      minusFuncs = state.minusFuncs,
      objDepMap = state.objDepMap,
      outputPath = state.outputPath,
      plusFuncs = state.plusFuncs,
      varDepMap = state.varDepMap;

  var identifiers = _.without(_.union(buildFuncs, includeObjs, includeVars), 'main'),
      removedDeps = {};

  var buildCallback = function(data) {
    var source = data.source;
    source = addCommandsToHeader(source, state.options);
    data.source = cleanupSource(source);
    defaultBuildCallback(data);
  };

  var getUnusedDeps = function(source, depNames) {
    source = cleanupSource(removeStrings(removeComments(source)));
    return _.reject(depNames, function(depName) {
      return RegExp('\\b' + depName + '\\b').test(source);
    });
  };

  var toDepName = !isNpm ? _.identity : function(value) {
    return 'lodash.' + (isPrivate(value) ? '_' : '') + value.toLowerCase();
  };

  if (isNpm) {
    // Load package templates.
    var templatePath = fs.realpathSync(path.join(__dirname, '..', 'template')),
        licenseTemplate = fs.readFileSync(path.join(templatePath, 'license.jst'), 'utf-8'),
        packageTemplate = fs.readFileSync(path.join(templatePath, 'package.jst'), 'utf-8'),
        readmeTemplate = fs.readFileSync(path.join(templatePath, 'readme.jst'), 'utf-8');

    // Exclude "Chain" methods & most internal functions when exporting for npm.
    identifiers = _.reject(_.difference(identifiers, categoryMap.Chain), function(identifier) {
      return isPrivate(identifier) && !_.includes(uninlinables, identifier) && !_.includes(includeFuncs, identifier);
    });

    // Remove unused packages.
    var glob = require('glob'),
        newPackages = _.map(identifiers, toDepName),
        oldPackages = _.map(glob.sync(path.join(outputPath, 'lodash.*')), _.ary(path.basename, 1)),
        unusedPackages = _.difference(oldPackages, newPackages);

    _.each(unusedPackages, function(packageName) {
      var pathname = path.join(outputPath, packageName);
      _.each(fs.readdirSync(pathname), function(identifier) {
        fs.unlinkSync(path.join(pathname, identifier));
      });
      fs.rmdirSync(pathname);
    });
  }
  // List of identifiers that keep their copyright/license headers.
  var includeHeaders = isNpm ? identifiers : _.difference(_.union(includeFuncs, plusFuncs), minusFuncs);
  if (_.isEmpty(includeHeaders)) {
    includeHeaders = ['main'];
  }
  // Create modules for each identifier.
  _.each(identifiers, function(identifier) {
    var categories = getCategories(identifier, funcDepMap);
    if (_.isEmpty(categories)) {
      categories.push(null);
    }
    _.each(isNpm ? categories.slice(0, 1) : categories, function(category) {
      var moduleName = isNpm ? toDepName(identifier) : identifier,
          modulePath = isNpm ? moduleName : getModulePath(identifier, category, funcDepMap);

      var depNames = _.union(
        getDependencies(identifier, funcDepMap),
        getDependencies(identifier, objDepMap),
        getDependencies(identifier, varDepMap)
      ).sort();

      if (isNpm) {
        var uninlinees = _.difference(uninlinables, forceInlineMap[identifier]);

        var inlinees = _.union(_.transform(_.difference(depNames, uninlinees), function(result, identifier) {
          push.apply(result, getAllDependencies([identifier], funcDepMap, objDepMap, varDepMap, _.clone(uninlinees)));
          return result;
        }));

        depNames = _.union(_.intersection(uninlinees, depNames), _.intersection(uninlinees, inlinees));
        inlinees = _.difference(inlinees, depNames).concat(identifier);

        var inlineFuncs = _.intersection(allFuncs, inlinees),
            inlineObjs = _.intersection(objDependencies, inlinees),
            inlineVars = _.intersection(varDependencies, inlinees);
      }
      else {
        inlinees = [identifier];
        inlineFuncs = _.includes(allFuncs, identifier) ? inlinees : [];
        inlineObjs = _.includes(objDependencies, identifier) ? inlinees : [];
        inlineVars = _.includes(varDependencies, identifier) ? inlinees : [];
      }
      state.outputPath = path.join(outputPath, modulePath, (isNpm ? 'index' : identifier) + '.js');
      state.buildFuncs = state.includeFuncs = inlineFuncs;
      state.includeObjs = inlineObjs;
      state.includeVars = inlineVars;

      build(state, function(data) {
        var iife = [],
            source = data.source,
            unusedDeps = getUnusedDeps(source, depNames);

        // Track and remove unused dependencies.
        removedDeps[identifier] = unusedDeps;
        depNames = _.sortBy(_.difference(depNames, unusedDeps), toDepName);

        var depPaths = isNpm
          ? _.map(depNames, toDepName)
          : getDepPaths(depNames, modulePath, funcDepMap);

        if (isAMD) {
          iife.push(
            'define([' + (_.isEmpty(depPaths) ? '' : "'" + depPaths.join("', '") + "'") + '], function(' + depNames.join(', ') + ') {',
            '%output%',
            '  return ' + identifier + ';',
            '});'
          );
        }
        else if (isES) {
          iife.push(
            _.reduce(depPaths, function(result, depPath, index) {
              var depName = depNames[index];
              return result + (result ? ';\n' : '') +
                'import ' + depName + " from '" + depPath + "'";
            }, '') + ';',
            '%output%',
            'export default ' + identifier + ';'
          );
        }
        else {
          iife.push(
            _.reduce(depPaths, function(result, depPath, index) {
              var depName = depNames[index];
              return result + (result ? ',\n    ' : 'var ') +
                depName + " = require('" + depPath + "')" +
                (isCommonJS ? '.' + depName : '');
            }, '') + ';',
            '%output%',
            (isCommonJS ? 'exports.' + identifier : 'module.exports') + ' = ' + identifier + ';'
          );
        }
        if (!isAMD) {
          source = trimIndent(source);
        }
        source = _.includes(includeHeaders, identifier) ? removeLicenseTag(source) : removeHeader(source);
        source = replaceIIFE(source, iife.join('\n'));

        if (isNpm) {
          var templatePath = fs.realpathSync(path.join(__dirname, '..', 'template')),
              licenseTemplate = fs.readFileSync(path.join(templatePath, 'license.jst'), 'utf-8'),
              packageTemplate = fs.readFileSync(path.join(templatePath, 'package.jst'), 'utf-8'),
              readmeTemplate = fs.readFileSync(path.join(templatePath, 'readme.jst'), 'utf-8');

          var type = 'function',
              version = state.lodash.VERSION;

          if (_.includes(objDependencies, identifier)) {
            type = 'object';
          } else if (_.includes(varDependencies, identifier)) {
            type = 'variable';
          }
          var templateData = {
            'identifier': identifier,
            'isInternal': isPrivate(identifier),
            'name': moduleName,
            'type': type,
            'version': version,
            'dependencies': _.transform(depPaths, function(result, depPath) {
              var parts = version.split('.');
              result[depPath] = '^' + parts[0] + '.0.0';
            }, {})
          };

          // Independently update the package version.
          if (fs.existsSync(data.outputPath)) {
            var semver = require('semver'),
                oldPackage = JSON.parse(fs.readFileSync(path.join(path.dirname(data.outputPath), 'package.json'), 'utf-8')),
                oldVersion = oldPackage.version;

            if (_.isEqual(oldPackage.dependencies || {}, templateData.dependencies)) {
              // Bump the `patch` version if the source has changed.
              var oldSource = fs.readFileSync(data.outputPath, 'utf-8');
              templateData.version = cleanupSource(removeComments(oldSource)) === cleanupSource(removeComments(source))
                ? oldVersion
                : semver.inc(oldVersion, 'patch', true);
            }
            else {
              // Bump the `minor` version if the dependencies have changed.
              templateData.version = semver.inc(oldVersion, 'minor', true);
            }
            source = source.replace(getHeader(source), function(header) {
              return header.replace(/^( \* *lodash )[.$\w\-]+/m, function(match, prelude) {
                return prelude + templateData.version;
              });
            });
          }
          fs.writeFileSync(path.join(outputPath, modulePath, 'package.json'), _.template(packageTemplate)(templateData), 'utf-8');
          fs.writeFileSync(path.join(outputPath, modulePath, 'LICENSE.txt'), _.template(licenseTemplate)(templateData), 'utf-8');
          fs.writeFileSync(path.join(outputPath, modulePath, 'README.md'), _.template(readmeTemplate)(templateData), 'utf-8');
        }
        data.source = source;
        buildCallback(data);
      });
    });
  });

  // Add alias modules.
  _.each(identifiers, function(identifier) {
    var aliases = !isNpm && getAliases(identifier);
    if (_.isEmpty(aliases)) {
      return;
    }
    var categories = getCategories(identifier, funcDepMap);
    if (_.isEmpty(categories)) {
      categories.push(null);
    }
    _.each(categories.slice(0, 1), function(category) {
      var modulePath = getModulePath(identifier, category, funcDepMap),
          depPath = getDepPath(identifier, modulePath, funcDepMap);

      _.each(aliases, function(alias) {
        var iife = [];
        if (isAMD) {
          iife.push(
            'define(["' + depPath + '"], function(' + identifier + ') {',
            '  return ' + identifier + ';',
            '});'
          );
        }
        else if (isES) {
          iife.push(
            'import ' + identifier + " from '" + depPath + "'",
            'export default ' + identifier + ';'
          );
        }
        else {
          iife.push(
            (isCommonJS ? ('exports.' + alias) : 'module.exports') +
            " = require('" + depPath + "')" + (isCommonJS ? '.' + identifier : '') + ';'
          );
        }
        buildCallback({
          'outputPath': path.join(outputPath, modulePath, alias + '.js'),
          'source': iife.join('\n')
        });
      });
    });
  });

  // Create main module.
  (function() {
    var identifier = 'main';
    if (isNpm || !_.includes(buildFuncs, identifier)) {
      return;
    }
    var modulePath = getModulePath(identifier, funcDepMap);

    var categories = _.uniq(_.compact(_.map(identifiers, function(identifier) {
      return _.first(getCategories(identifier, funcDepMap));
    }))).sort();

    var categoryDeps = _.map(categories, _.propertyOf(categoryToDepNameMap));

    var categoryDepPaths = _.map(categories, function(category) {
      return './' + category.toLowerCase();
    });

    var deps = _.union(
      getDependencies(identifier, funcDepMap),
      getDependencies(identifier, objDepMap),
      getDependencies(identifier, varDepMap)
    ).sort();

    var basename = 'index';
    if (isAMD) {
      basename = 'main';
    } else if (isES) {
      basename = 'lodash';
    }
    state.buildFuncs = state.includeFuncs = [identifier];
    state.includeObjs = state.includeVars = [];
    state.outputPath = path.join(outputPath, modulePath, basename + '.js');

    build(state, function(data) {
      var source = data.source;

      // Remove unneeded method and alias assignments.
      _.each(_.difference(allFuncs, buildFuncs), function(funcName) {
        source = removeMethodAssignment(source, funcName);
      });

      // Wrap `_.mixin`.
      source = source.replace(/^(?: *\/\/.*\n)* *lodash\.[$\w]+\s*=[^;]+;\n/m, function(match) {
        var code = [
          '  // wrap `_.mixin` so it works when provided only one argument',
          '  ' + (isES ? 'var ' : '') + 'mixin = (function(func) {'
        ];

        code.push(
          '    return function(object, source, options) {',
          '      if (options == null) {',
          '        var isObj = isObject(source),',
          '            props = isObj && keys(source),',
          '            methodNames = props && props.length && baseFunctions(source, props);',
          '',
          '        if (!(methodNames ? methodNames.length : isObj)) {',
          '          options = source;',
          '          source = object;',
          '          object = this;',
          '        }',
          '      }',
          '      return func(object, source, options);',
          '    };',
          '  }(' + (isES ? '_' : '') + 'mixin));',
          '',
          match
        );

        return code.join('\n');
      });

      // Add `lodash.support`, `lodash.templateSettings`, & placeholder assignments.
      source = source.replace(/^ *lodash\.VERSION\b.+\n/m, function(match) {
        var code = [
          '',
          '  lodash.support = support;'
        ];

        if (_.includes(identifiers, 'templateSettings')) {
          code.push('  (lodash.templateSettings = ' + categoryToDepNameMap.String + '.templateSettings).imports._ = lodash;');
        }
        var funcNames = _.intersection(buildFuncs, placeholderFuncs);
        if (!_.isEmpty(funcNames)) {
          code.push(
            '',
            '  // Assign default placeholders.'
          );
          if (_.size(funcNames) > 1) {
            code.push(
              "  arrayEach(['" + funcNames.join("', '") + "'], function(methodName) {",
              '    lodash[methodName].placeholder = lodash;',
              '  });'
            );
          } else {
            code.push('  lodash.' + funcNames[0] + '.placeholder = lodash;');
          }
        }
        code.push('');
        return match + code.join('\n');
      });

      // Add category namespaces to each lodash function assignment.
      source = source.replace(/(lodash(?:\.prototype)?\.[$\w]+\s*=\s*)([$\w]+)/g, function(match, left, identifier) {
        if (_.includes(deps, identifier)) {
          return match;
        }
        var category = categoryToDepNameMap[_.first(getCategories(identifier, funcDepMap))];
        return left + (category ? category + '.' : '') + _.result(forceAliasMap, identifier, identifier);
      });

      // Track and remove unused dependencies.
      var unusedDeps = getUnusedDeps(source, deps);
      removedDeps[identifier] = unusedDeps;
      deps = _.difference(deps, unusedDeps);

      var depNames = categoryDeps.concat(deps);
      if (isES) {
        // Avoid a syntax error caused by reassigning `mixin` by naming the
        // dependency `_mixin` instead.
        depNames[_.indexOf(depNames, 'mixin')] = '_mixin';
      }
      var iife = [],
          depArgs = depNames.join(', '),
          depPaths = categoryDepPaths.concat(getDepPaths(deps, modulePath, funcDepMap));

      if (isAMD) {
        iife.push(
          'define([' + (_.isEmpty(depPaths) ? '' : "'" + depPaths.join("', '") + "'") + '], function(' + depArgs + ') {',
          '%output%',
          '  return lodash;',
          '});'
        );
      }
      else if (isES) {
        iife.push(
          _.reduce(depPaths, function(result, depPath, index) {
            var depName = depNames[index];
            return result + (result ? ';\n' : '') +
              'import ' + depName + " from '" + depPath + "'";
          }, '') + ';',
          '%output%',
          'export default lodash;'
        );
      }
      else {
        iife.push(
          _.reduce(depPaths, function(result, depPath, index) {
            var depName = depNames[index];
            return result + (result ? ',\n    ' : 'var ') +
              depName + " = require('" + depPath + "')" +
              (isCommonJS && !_.includes(categoryDepPaths, depPath) ? '.' + depName : '');
          }, '') + ';',
          '%output%',
          (isCommonJS ? 'exports._' : 'module.exports') + ' = lodash;'
        );
      }
      if (!isAMD) {
        source = trimIndent(source);
      }
      if (!_.includes(includeHeaders, identifier)) {
        source = removeHeader(source);
      }
      source = replaceIIFE(source, iife.join('\n'));

      data.source = source;
      buildCallback(data);
    });
  }());

  // Create category modules.
  _.each(_.uniq(_.compact(_.flatten(_.map(identifiers, _.partial(getCategories, _, funcDepMap))))), function(category) {
    if (isNpm) {
      return;
    }
    var depNames = _.transform(_.intersection(getNamesByCategory(category), identifiers), function(result, depName) {
      if (!forceAliasMap[depName]) {
        result.push(depName);
      }
      push.apply(result, getAliases(depName));
    })
    .sort();

    var iife = [],
        depPaths = getDepPaths(depNames, null, funcDepMap);

    if (isAMD) {
      iife.push(
        "define(['" + depPaths.join("', '") + "'], function(" + depNames.join(', ') + ') {',
        '  return {',
        _.map(depNames, function(depName) {
          return "    '" + depName + "': " + depName;
        })
        .join(',\n'),
        '  };',
        '});'
      );
    }
    else {
      if (isES) {
        push.apply(iife,
          _.map(depNames, function(depName, index) {
            return 'import ' + depName + " from '" + depPaths[index] + "';";
          })
        );

        iife.push(
          '',
          'export default {',
          _.map(depNames, function(depName) {
            return "  '" + depName + "': " + depName;
          })
          .join(',\n'),
          '};'
        );
      }
      else if (isCommonJS) {
        push.apply(iife,
          _.map(depNames, function(depName) {
            var depPath = depPaths[_.indexOf(depNames, depName)];
            return 'exports.' + depName + " = require('" + depPath + "')." + depName + ';';
          })
        );
      }
      else {
        iife.push(
          'module.exports = {',
          _.map(depNames, function(depName) {
            var depPath = depPaths[_.indexOf(depNames, depName)];
            return "  '" + depName + "': require('" + depPath + "')";
          })
          .join(',\n'),
          '};'
        );
      }
    }
    buildCallback({
      'outputPath': path.join(outputPath, category.toLowerCase() + '.js'),
      'source': iife.join('\n')
    });
  });

  if (!isNpm && !isSilent) {
    // Warn of removed dependencies.
    _.forOwn(removedDeps, function(depNames, identifier) {
      if (!_.isEmpty(depNames)) {
        var plural = _.size(depNames) > 1;
        console.warn('Warning: Removed ' + (plural ? '' : 'an ') + 'unused dependenc' + (plural ? 'ies' : 'y') + ' from `' + identifier + '`: ' + depNames.join(', '));
      }
    });
  }
  if (onComplete) {
    onComplete({ 'outputPath': fs.realpathSync(outputPath) });
  }
}

/**
 * Compiles template files based on the provided build state extending
 * `_.templates` with precompiled templates named after each file's basename.
 *
 * @private
 * @param {Object} state The build state object.
 * @returns {string} Returns the compiled source.
 */
function buildTemplate(state) {
  var moduleId = state.moduleId || 'lodash',
      isStandalone = moduleId == 'none',
      pattern = state.templatePattern,
      settings = state.templateSettings;

  pattern = path.normalize(pattern || path.join(cwd, '*.jst'));

  var hr = '  /*----------------------------------------------------------------------------*/';

  var source = [
    ';(function() {',
    '  var undefined;',
    '',
    '  var objectTypes = {',
    "    'function': true,",
    "    'object': true",
    '  };',
    '',
    '  var root = (objectTypes[typeof window] && window !== (this && this.window)) ? window : this;',
    '',
    '  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;',
    '',
    '  var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;',
    '',
    "  var freeGlobal = freeExports && freeModule && typeof global == 'object' && global;",
    '  if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal)) {',
    '    root = freeGlobal;',
    '  }',
    '',
    '  var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;',
    ''
  ];

  if (isStandalone) {
    build(['exports=none', 'include=escape', 'iife=%output%', '-d', '-s'], function(data) {
      var escapeSource = data.source;
      escapeSource = removeHeader(escapeSource);
      escapeSource = removeFunction(escapeSource, 'lodash');
      escapeSource = removeAssignments(escapeSource);
      escapeSource = cleanupSource(escapeSource);

      source.push(
        '',
        escapeSource,
        '',
        "  var _ = { 'escape': escape };",
        ''
      );
    });
  }
  else {
    source.push(
      '  var _ = root._ || {};',
      ''
    );
  }
  source.push(
    hr,
    ''
  );

  var glob = require('glob'),
      dirname = path.dirname(pattern),
      filePaths = glob.sync(pattern);

  if (dirname == '.') {
    dirname = '';
  }
  var basePath = (dirname + path.sep).replace(RegExp('(^|' + path.sepEscaped + ')\\*\\*.*$'), '$1'),
      insertAt = source.length,
      templates = createMap();

  _.each(filePaths, function(filePath) {
    var string = fs.readFileSync(filePath, 'utf8'),
        precompiled = cleanupCompiled(getFunctionSource(_.template(string, settings), 2));

    // Glob uses *nix path separators even on Windows.
    // See https://github.com/isaacs/node-glob#windows.
    var clipped = filePath.slice(dirname ? basePath.length : 0).replace(/\..*$/, ''),
        props = clipped.split('/');

    // Create namespace objects.
    _.reduce(props, function(object, key) {
      return object[key] || (object[key] = createMap());
    }, templates);

    // Escape namespace property names.
    props = _.map(props, function(key) {
      return "['" + key.replace(/['\n\r\t]/g, '\\$&') + "']";
    });

    // Add template assignment to `source`.
    source.push('  templates' + props.join('') + ' = ' + precompiled + ';', '');
  });

  // Add the initial `_.templates` object to `source`.
  source.splice(insertAt, 0, '  var templates = ' +
    JSON.stringify(templates, null, 4)
      .replace(/^ *\}$/m, '  $&')
      .replace(/'/g, "\\'")
      .replace(/([^\\])"/g, "$1'") +
    ';',
    ''
  );

  source.push(
    hr,
    '',
    "  if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {"
  );

  if (isStandalone) {
    source.push(
      '    define(function() {',
      '      return templates;'
    );
  }
  else {
    source.push(
      "    define(['" + moduleId + "'], function(lodash) {",
      '      _ = lodash;',
      '      lodash.templates = lodash.extend(lodash.templates || {}, templates);'
    );
  }
  source.push(
    '    });',
    '  }',
    '  else if (freeExports && freeModule) {'
  );

  if (!isStandalone) {
    source.push("    _ = require('" + moduleId + "');");
  }
  source.push(
    '    if (moduleExports) {',
    '      (freeModule.exports = templates).templates = templates;',
    '    } else {',
    '      freeExports.templates = templates;',
    '    }'
  );

  if (isStandalone) {
    source.push(
      '  }',
      '  else {',
      '    root.templates = templates;',
      '  }'
    );
  }
  else {
    source.push(
      '  }',
      '  else if (_) {',
      '    _.templates = _.extend(_.templates || {}, templates);',
      '  }'
    );
  }
  source.push('}.call(this));');
  return source.join('\n');
}

/**
 * Removes unnecessary semicolons and whitespace from compiled code.
 *
 * @private
 * @param {string} source The source to process.
 * @returns {string} Returns the modified source.
 */
function cleanupCompiled(source) {
  return stringFree(source, function(source) {
    return source
      .replace(/\b(function)\s*(\()/g, '$1$2')
      .replace(/([{}])\s*;/g, '$1');
  });
}

/**
 * Removes unnecessary comments, and whitespace.
 *
 * @private
 * @param {string} source The source to process.
 * @returns {string} Returns the modified source.
 */
function cleanupSource(source) {
  return stringFree(source, function(source) {
    return source
      // Consolidate consecutive horizontal rule comment separators.
      .replace(/(?:\s*\/\*-+\*\/\s*){2,}/g, function(separators) {
        var indent = /^\s*/.exec(separators)[0];
        return indent + separators.slice(separators.lastIndexOf('/*'));
      })
      // Remove unneeded single line comments.
      .replace(/(\{\s*)?(\n *\/\/.*)(\s*\})/g, function(match, prelude, comment, postlude) {
        return (!prelude && postlude) ? postlude : match;
      })
      // Remove unneeded horizontal rule comment separators.
      .replace(/(\{\s*\n) *\/\*-+\*\/\n|^ *\/\*-+\*\/\n(\s*\})/gm, '$1$2')
      // Remove trailing horizontal rule comment separators.
      .replace(/\s*\/\*-+\*\/\s*$/, '')
      // Remove lines with just spaces and semicolons.
      .replace(/^ *;\n/gm, '')
      // Remove trailing spaces from lines.
      .replace(/ *$/gm, '')
      // Consolidate multiple newlines.
      .replace(/\n{3,}/g, '\n\n')
      // Remove leading empty lines.
      .replace(/^ *\n+/, '')
      // Add trailing newline.
      .trimRight() + '\n';
  });
}

/**
 * Creates a map object. If a `properties` object is provided its own
 * enumerable properties are assigned to the created object.
 *
 * @private
 * @param {Object} [properties] The properties to assign to the object.
 * @returns {Object} Returns the new object.
 */
function createMap(properties) {
  return _.assign(Object.create(null), properties);
}

/**
 * The default callback used for `build` invocations.
 *
 * @private
 * @param {Object} data The data for the given build.
 *  gzip - The gzipped output of the built source
 *  outputPath - The path where the built source is to be written
 *  source - The built source output
 *  sourceMap - The source map output
 */
function defaultBuildCallback(data) {
  var outputPath = data.outputPath,
      sourceMap = data.sourceMap;

  if (outputPath) {
    fs.writeFileSync(outputPath, data.source, 'utf8');
    if (sourceMap) {
      fs.writeFileSync(path.join(path.dirname(outputPath), path.basename(outputPath, '.js') + '.map'), sourceMap, 'utf8');
    }
  }
}

/**
 * Gets the aliases associated with a given function name.
 *
 * @private
 * @param {string} funcName The name of the function to get aliases for.
 * @returns {Array} Returns an array of aliases.
 */
function getAliases(funcName) {
  return _.result(realToAliasMap, funcName, []);
}

/**
 * Creates an array of all function, object, and variable dependencies for the
 * given identifier(s).
 *
 * @private
 * @param {string|string[]} identifier The identifier or array of identifiers to query.
 * @param {Object} funcDepMap The dependency map to look up function dependencies.
 * @param {Object} objDepMap The dependency map to look up object dependencies.
 * @param {Object} varDepMap The dependency map to look up variable dependencies.
 * @param- {Array} [stackA=[]] Internally used track queried identifiers.
 * @returns {Array} Returns an array of identifier dependencies.
 */
function getAllDependencies(identifier, funcDepMap, objDepMap, varDepMap, stack) {
  var result = identifier;
  if (!_.isArray(stack)) {
    result = _.isArray(identifier) ? _.clone(identifier) : [identifier];
    stack = [];
  }
  _.each(result, function(identifier) {
    if (!_.includes(stack, identifier)) {
      stack.push(identifier);

      push.apply(result, getDependencies(identifier, funcDepMap));
      push.apply(result, getDependencies(identifier, objDepMap));
      push.apply(result, getDependencies(identifier, varDepMap));
      getAllDependencies(result, funcDepMap, objDepMap, varDepMap, stack);
    }
  });
  return stack ? result : _.uniq(result);
}

/**
 * Gets the categories of the given identifier.
 *
 * @private
 * @param {string} identifier The identifier to query.
 * @param {Object} [funcDepMap] The dependency map used to resolve the identifier.
 * @returns {Array} Returns the array of categories.
 */
function getCategories(identifier, funcDepMap) {
  identifier = getRealName(identifier);
  return _.filter(allCategories, function(category) {
    return _.includes(categoryMap[category], identifier);
  });
}

/**
 * Gets the `bufferClone` fork from `source`.
 *
 * @private
 * @param {string} source The source to inspect.
 * @returns {string} Returns the fork.
 */
function getBufferCloneFork(source) {
  return _.result(/^(?: *\/\/.*\n)*( *)if\s*\(!bufferSlice\b[\s\S]+?\n\1  bufferClone\s*=[\s\S]+?\n\1\}\n/m.exec(source), 0, '');
}

/**
 * Resolves the path of the given module dependency. If `fromPath` is
 * provided the resolved path will be relative to `fromPath`.
 *
 * @private
 * @param {string} depName The name of the dependency.
 * @param {string} [fromPath=''] The path to resolve the dependency relative to.
 * @param {Object} [funcDepMap] The dependency map used to resolve identifiers.
 * @returns {string} Returns the dependency path.
 */
function getDepPath(depName, fromPath, funcDepMap) {
  var sep = '/',
      toPath = getModulePath(depName, funcDepMap),
      relative = path.relative(fromPath || '', toPath).replace(RegExp(path.sepEscaped, 'g'), sep);

  if (relative.charAt(0) != '.') {
    relative = '.' + (relative ? sep + relative : '');
  }
  return relative + sep + depName;
}

/**
 * Resolves the paths of the given module dependencies. If `fromPath` is
 * provided the resolved path will be relative to `fromPath`.
 *
 * @private
 * @param {Array} depNames The array dependency names.
 * @param {string} [fromPath=''] The path to resolve dependencies relative to.
 * @param {Object} [funcDepMap] The dependency map used to resolve identifiers.
 * @returns {string[]} Returns the dependency paths.
 */
function getDepPaths(depNames, fromPath, funcDepMap) {
  return _.map(depNames, function(depName) {
    return getDepPath(depName, fromPath, funcDepMap);
  });
}

/**
 * Creates an array of depenants for the given identifier(s).
 *
 * @private
 * @param {string} identifier The identifier or array of identifiers to query.
 * @param {Object} depMap The dependency map to look up dependants.
 * @param {boolean} [isDeep=false] A flag to specify retrieving nested dependants.
 * @param- {Array} [stackA=[]] Internally used track queried identifiers.
 * @returns {Array} Returns an array of identifier dependants.
 */
function getDependants(identifier, depMap, isDeep, stack) {
  var identifiers = _.isArray(identifier) ? identifier : [identifier];
  stack || (stack = []);

  // Iterate over the dependency map, adding names of functions that have `identifier` as a dependency.
  return _.uniq(_.transform(depMap, function(result, depNames, otherName) {
    if (!_.includes(stack, otherName) &&
        _.some(identifiers, _.partial(_.includes, depNames, _, 0))) {
      result.push(otherName);
      if (isDeep) {
        stack.push(otherName);
        push.apply(result, getDependants(otherName, depMap, isDeep, stack));
      }
    }
  }, []));
}

/**
 * Creates an array of dependencies for the given identifier(s).
 *
 * @private
 * @param {string|string[]} identifier The identifier or array of identifiers to query.
 * @param {Object} depMap The dependency map to look up dependencies.
 * @param {boolean} [isDeep=false] A flag to specify retrieving nested dependencies.
 * @param- {Array} [stackA=[]] Internally used track queried identifiers.
 * @returns {Array} Returns an array of identifier dependencies.
 */
function getDependencies(identifier, depMap, isDeep, stack) {
  var depNames = _.isArray(identifier) ? identifier : depMap[identifier];
  if (!isDeep) {
    return _.clone(depNames);
  }
  stack || (stack = []);

  // Recursively accumulate the dependencies of the `identifier` function,
  // the dependencies of its dependencies, and so on.
  return _.uniq(_.transform(depNames, function(result, otherName) {
    if (!_.includes(stack, otherName)) {
      stack.push(otherName);
      result.push(otherName);
      push.apply(result, getDependencies(otherName, depMap, isDeep, stack));
    }
  }));
}

/**
 * Gets the formatted source of the given function.
 *
 * @private
 * @param {Function} func The function to process.
 * @param {number|string} [indent=0] The level to indent.
 * @returns {string} Returns the formatted source.
 */
function getFunctionSource(func, indent) {
  var source = String(func.source || func),
      srcIndent = getIndent(source),
      forceIndent = _.size(source.match(RegExp('^' + srcIndent + '}', 'gm'))) > 1;

  indent || (indent = '');
  if (typeof indent == 'number') {
    indent = _.repeat(' ', indent);
  }
  // Remove any existing indent.
  if (srcIndent) {
    source = source.replace(RegExp('^' + srcIndent, 'gm'), '');
  }
  // Set indent of source.
  return indent + source.replace(/\n(?:.*)/g, function(match, index) {
    var prelude = '\n' + indent;
    match = match.slice(1);
    if (forceIndent) {
      prelude += (match == '}' && !_.includes(source, '}', index + 2) ? '' : '  ');
    }
    return prelude + match;
  });
}


/**
 * Gets the copyright/license header of `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @returns {string} Returns the copyright/license header.
 */
function getHeader(source) {
  source = source == null ? '' : String(source);
  return _.result(/^(?:\s*\/\*[^*]*\*+(?:[^\/][^*]*\*+)*\/|\s*\/\/.*)*\n/.exec(source), 0, '');
}

/**
 * Gets the indent of the given function.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the indent.
 */
function getIndent(func) {
  return /^ *(?=\S)/m.exec(func.source || func)[0];
}

/**
 * Gets the `_.isArguments` fork from `source`.
 *
 * @private
 * @param {string} source The source to inspect.
 * @returns {string} Returns the fork.
 */
function getIsArgumentsFork(source) {
  return _.result(/^(?: *\/\/.*\n)*( *)if\s*\((?:!support\.argsTag|!isArguments)\b[\s\S]+?\n\1  isArguments\s*=[\s\S]+?\n\1\}\n/m.exec(source), 0, '');
}

/**
 * Gets the `_.isArray` fork from `source`.
 *
 * @private
 * @param {string} source The source to inspect.
 * @returns {string} Returns the fork.
 */
function getIsArrayFork(source) {
  return matchFunction(source, 'isArray')
    .replace(/^[\s\S]+?(?=\|\|)/, '')
    .replace(/[;\s]+$/, '');
}

/**
 * Gets the `_.isElement` fork from `source`.
 *
 * @private
 * @param {string} source The source to inspect.
 * @returns {string} Returns the fork.
 */
function getIsElementFork(source) {
  return _.result(/^(?: *\/\/.*\n)*( *)if\s*\(!support\.dom\b[\s\S]+?\n\1  isElement\s*=[\s\S]+?\n\1\}\n/m.exec(source), 0, '');
}

/**
 * Gets the `_.isFunction` fork from `source`.
 *
 * @private
 * @param {string} source The source to inspect.
 * @returns {string} Returns the fork.
 */
function getIsFunctionFork(source) {
  return _.result(/^(?: *\/\/.*\n)*( *)if\s*\(isFunction\(\/x\/[\s\S]+?\n\1  isFunction\s*=[\s\S]+?\n\1\}\n/m.exec(source), 0, '');
}

/**
 * Gets the lodash method assignments snippet from `source`.
 *
 * @private
 * @param {string} source The source to inspect.
 * @returns {string} Returns the method assignments snippet.
 */
function getMethodAssignments(source) {
  return _.result(/\n\n(?: *\/\/.*\n)* *lodash(?:\.[$\w]+)+\s*=[\s\S]+lodash(?:\.[$\w]+)+\s=.+/.exec(source), 0, '');
}

/**
 * Resolves the module path of the given identifier.
 *
 * @private
 * @param {string} identifier The module identifier.
 * @param {string} [category] The category of the identifier.
 * @param {Object} [funcDepMap] The dependency map used to resolve identifiers.
 * @returns {string} Returns the module path.
 */
function getModulePath(identifier, category, funcDepMap) {
  if (topLevel[identifier]) {
    return '';
  }
  if (isPrivate(identifier)) {
    return 'internal';
  }
  if (_.isObject(category)) {
    funcDepMap = category;
    category = null;
  }
  if (category == null) {
    category = _.first(getCategories(identifier, funcDepMap));
  }
  return category.toLowerCase();
}

/**
 * Gets the names of identifiers in `source` that belong to the given category.
 *
 * @private
 * @param {string} category The category to filter by.
 * @returns {Array} Returns a new array of names.
 */
function getNamesByCategory(category) {
  return _.result(categoryMap, category, []);
}

/**
 * Gets the `_.isArray` fork from `source`.
 *
 * @private
 * @param {string} source The source to inspect.
 * @returns {string} Returns the fork.
 */
function getNowFork(source) {
  return matchFunction(source, 'now')
    .replace(/^[\s\S]+?(?=\|\|)/, '')
    .replace(/[;\s]+$/, '');
}

/**
 * Gets the value of a given name from the `options` array. If no value is
 * available the `defaultValue` is returned.
 *
 * @private
 * @param {Array} options The options array to inspect.
 * @param {string} name The name of the option.
 * @param {*} defaultValue The default option value.
 * @returns {*} Returns the option value.
 */
function getOption(options, name, defaultValue) {
  var isArr = _.isArray(defaultValue);
  return _.reduce(options, function(result, value) {
    if (isArr) {
      value = optionToArray(name, value);
      return _.isEmpty(value) ? result : value;
    }
    value = optionToValue(name, value);
    return value == null ? result : value;
  }, defaultValue);
}

/**
 * Gets the `_.parseInt` fork from `source`.
 *
 * @private
 * @param {string} source The source to inspect.
 * @returns {string} Returns the fork.
 */
function getParseIntFork(source) {
  return _.result(/^(?: *\/\/.*\n)*( *)if\s*\(nativeParseInt\(whitespace\b[\s\S]+?\n\1  parseInt\s*=[\s\S]+?\n\1\}\n/m.exec(source), 0, '');
}

/**
 * Gets the real function name of `alias`.
 *
 * @private
 * @param {string} alias The alias to resolve.
 * @returns {string} Returns the real name.
 */
function getRealName(alias) {
  return _.result(aliasToRealMap, alias, alias);
}

/**
 * Gets the real category of `alias`.
 *
 * @private
 * @param {string} alias The alias to resolve.
 * @returns {string} Returns the real category.
 */
function getRealCategory(alias) {
  return _.result(aliasToCategoryMap, alias, alias);
}

/**
 * Creates an array variables names from all variables defined outside of
 * lodash functions.
 *
 * @private
 * @param {string} source The source to process.
 * @returns {Array} Returns a new array of variable names.
 */
function getVars(source) {
  source = removeStrings(removeComments(source));

  // Remove all functions except `runInContext`.
  source = source
    .replace(/^( *)function\s+(?!runInContext)[\s\S]+?\{\n[\s\S]+?\n\1\}\n/gm, '')
    .replace(/^( *)(?:var\s+)?[$\w]+\s*=\s*function\([\s\S]+?\{\n[\s\S]+?\n\1\};\n/gm, '')
    .replace(/^( *)(?:var\s+)?[$\w]+\s*=.*?create[A-Z][a-z]+\((?:.+|[\s\S]+?\n\1(?:\S.*?)?)\);\n/gm, '');

  var isDeep = reDeepVars.test(source),
      indentA = isDeep ? ' {2,4}' : ' {2}',
      indentB = isDeep ? ' {6,8}' : ' {6}';

  var reAttempts = [
    // Match a varaible at the start of a declaration list.
    ['^(' + indentA + 'var\\s+)([$\\w]+)\\s*=.+?,\\n *', 2, 1],
    // Match a variable declaration in a declaration list.
    [',\\n' + commentPattern + indentB + '([$\\w]+)\\s*=[\\s\\S]+?(?=[,;]\\n)', 1, -1],
    // Match a variable that is not part of a declaration list.
    ['^(' + indentA + ')var\\s+([$\\w]+)\\s*(?:|=\\s*(?:.+?(?:[&+]\\n[\\s\\S]+?)?|(?:[($\\w]+\\(|[{[(]\\n)[\\s\\S]+?\\n\\1\\S+?));\\n', 2, -1]
  ];

  return _.uniq(_.transform(reAttempts, function(result, data) {
    source = source.replace(RegExp(data[0], 'gm'), function() {
      result.push(arguments[data[1]]);
      return data[2] > -1 ? arguments[data[2]] : '';
    });
  }));
}

/**
 * Checks if `source` is a function snippet.
 *
 * @private
 * @param {string} source The source to inspect.
 * @returns {boolean} Returns `true` for a function snippet, else `false`.
 */
function isFunctionSnippet(source) {
  source = source == null ? '' : String(source);
  var header = getHeader(source);
  return (header && reFuncTag.test(header)) || reFuncSnippet.test(source.replace(header, ''));
}

/**
 * Checks if `identifier` is private.
 *
 * @private
 * @param {string} identifier The identifier to query.
 * @returns {boolean} Returns `true` if the identifier is private, else `false`.
 */
function isPrivate(identifier) {
  identifier = getRealName(identifier);
  if (topLevel[identifier]) {
    return false;
  }
  return _.findKey(categoryMap, function(identifiers) {
    return _.includes(identifiers, identifier);
  }) === undefined;
}

/**
 * Checks if the variable `varName` is used in `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @param {string} varName The name of the variable.
 * @returns {boolean} Returns `true` if the variable is used, else `false`.
 */
function isVarUsed(source, varName) {
  source = source == null ? '' : String(source);
  var snippet = matchVar(source, varName);

  if (!snippet) {
    return false;
  }
  // Remove the variable assignment from the source.
  source = source.replace(snippet, '');
  return RegExp('[^.$"\'\\w]' + _.escapeRegExp(varName) + '\\b(?!\\s*=)').test(source);
}

/**
 * Searches `source` for a `funcName` function declaration, expression, or
 * assignment and returns the matched snippet.
 *
 * @private
 * @param {string} source The source to inspect.
 * @param {string} funcName The name of the function to match.
 * @param {boolean} [leadingComments] A flag to specify including leading comments.
 * @returns {string} Returns the matched function snippet.
 */
function matchFunction(source, funcName, leadingComments) {
  funcName = _.escapeRegExp(funcName);

  var reAttempts = [
    // Match a function declaration.
    '( *)function\\s+' + funcName + '\\((?:\\)\\s*\\{\\s*|[\\s\\S]+?\\n\\3)\\}\\n',
    // Match a simple variable declaration.
    ' *var\\s+' + funcName + '\\s*=.+?;\\n',
    // Match variable declarations using `createAggregator`, or `createCompounder`.
    '( *)var\\s+' + funcName + '\\s*=.*?create[A-Z][a-z]+\\((?:.+|[\\s\\S]+?\\n\\3(?:\\S.*?)?)\\);\\n',
    // Match a variable declaration with function expression.
    '( *)var\\s+' + funcName + '\\s*=.*?function\\([\\s\\S]+?\\{\\n[\\s\\S]+?\\n\\3\\}(?:\\(\\)\\))?;\\n'
  ];

  return _.reduce(reAttempts, function(result, reSource, index) {
    if (result) {
      return result;
    }
    result = RegExp('^(' + commentPattern + ')(' + reSource + ')', 'm').exec(source);
    return (result && isFunctionSnippet(result)) ? result[leadingComments ? 0 : 2] : '';
  }, '');
}

/**
 * Searches `source` for a lodash property, of the given property name, and
 * returns the matched snippet.
 *
 * @private
 * @param {string} source The source to inspect.
 * @param {string} propName The name of the property to match.
 * @param {boolean} [leadingComments] A flag to specify including leading comments.
 * @returns {string} Returns the matched property snippet.
 */
function matchProp(source, propName, leadingComments) {
  propName = _.escapeRegExp(propName);

  return _.result(RegExp(
    '^' + (leadingComments ? commentPattern : '') +
    '(?: {2,4}var\\s+' + propName + '\\b.+|(?:\\s*|.*?=\\s*)lodash\\._?' + propName + '\\s*)=[\\s\\S]+?' +
    '(?:\\(function\\([\\s\\S]+?\\}\\([^)]*\\)\\);\\n(?=\\n)|' +
    '[;}]\\n(?=\\n(?!\\s*\\(function\\b)))'
  , 'm').exec(source), 0, '');
}

/**
 * Searches `source` for a `varName` variable assignment and returns
 * the matched snippet.
 *
 * @private
 * @param {string} source The source to inspect.
 * @param {string} varName The name of the variable to match.
 * @param {boolean} [leadingComments] A flag to specify including leading comments.
 * @returns {string} Returns the matched variable snippet.
 */
function matchVar(source, varName, leadingComments) {
  varName = _.escapeRegExp(varName);

  var reAttempts = [
    // Match a varaible at the start of a declaration list.
    ['^( *var\\s+)(' + varName + '\\s*=.+?,\\n *)', 2, 2],
    // Match a variable declaration in a declaration list.
    ['(,\\n' + commentPattern + ')( *' + varName + '\\s*=[\\s\\S]+?(?=[,;]\\n))', 2, 0],
    // Match a variable that is not part of a declaration list.
    ['^(' + commentPattern + ')(( *)var\\s+' + varName + '\\s*(?:|=\\s*(?:.+?(?:[&+]\\n[\\s\\S]+?)?|(?:[($\\w]+\\(|[{[(]\\n)[\\s\\S]+?\\n\\3\\S+?));\\n)', 2, 0]
  ];

  // Match complex variable assignments.
  if (_.includes(complexVars, varName)) {
    reAttempts.splice(2, 0, ['^(' + commentPattern + ')(( *)var\\s+' + varName + '\\s*=[\\s\\S]+?[};]\\n(?=\\s*\\n(?:\\S|\\3(?:function\\b|if\\b|lodash\\b|var\\s|/[/*]))))', 2, 0]);
  }
  return _.reduce(reAttempts, function(result, data) {
    return result || _.result(RegExp(data[0], 'm').exec(source), data[leadingComments ? 2 : 1], '');
  }, '');
}

/**
 * Converts a comma separated option value into an array.
 *
 * @private
 * @param {string} name The name of the option to inspect.
 * @param {string} string The options string.
 * @returns {Array} Returns the new converted array.
 */
function optionToArray(name, string) {
  return _.compact(_.invoke((optionToValue(name, string) || '').split(/, */), 'trim'));
}

/**
 * Extracts the option value from an option string.
 *
 * @private
 * @param {string} name The name of the option to inspect.
 * @param {string} string The options string.
 * @returns {string|undefined} Returns the option value, else `undefined`.
 */
function optionToValue(name, string) {
  var result = RegExp('^' + _.escapeRegExp(name) + '(?:=([\\s\\S]+))?$').exec(string);

  if (result) {
    result = _.result(result, 1);
    result = result ? _.trim(result) : true;
  }
  if (result === 'false') {
    return false;
  }
  return result || undefined;
}

/**
 * Removes all lodash method and property assignments from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @returns {string} Returns the modified source.
 */
function removeAssignments(source) {
  // Remove method and intermediate assignments.
  source = removeMethodAssignments(source);
  return source.replace(/(=\s*)lodash\.[$\w]+\s*=\s*/g, '$1');
}

/**
 * Removes the `bufferClone` fork from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @returns {string} Returns the modified source.
 */
function removeBufferCloneFork(source) {
  source = source == null ? '' : String(source);
  return source.replace(getBufferCloneFork(source), '');
}

/**
 * Removes support for lodash wrapper chaining in `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @returns {string} Returns the modified source.
 */
function removeChaining(source) {
  source = removeLazyChaining(source);
  source = removeMixinCalls(source);
  source = removeSpliceObjectsFix(source);

  // Remove all `lodash.prototype` additions.
  return source
    .replace(/^(?: *\/\/.*\n)*( *)arrayEach\(\['concat\b[\s\S]+?\n\1\}\);\n/m, '')
    .replace(/^(?: *\/\/.*\n)*( *)lodash\.prototype\.[$\w]+\s*=\s*(?:function\([\s\S]+?\n\1\}|.+?);\n/gm, '');
}

/**
 * Removes all comments from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @returns {string} Returns the modified source.
 */
function removeComments(source) {
  source = source == null ? '' : String(source);
  return source.replace(/^ *(?:\/\*[^*]*\*+(?:[^\/][^*]*\*+)*\/|\/\/.+)\n/gm, '');
}

/**
 * Removes support for lazy chaining in `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @returns {string} Returns the modified source.
 */
function removeLazyChaining(source) {
  // Remove bulk `LazyWrapper.prototype` assignments.
  source = source.replace(/^(?: *\/\/.*\n)*( *)arrayEach\(\['(?:drop|filter|first|initial|pluck)\b[\s\S]+?\n\1\}\);\n/gm, '');

  // Remove `LazyWrapper` methods `dropWhile`, `reject`, and `slice` assignments.
  source = source.replace(/^(?: *\/\/.*\n)*( *)LazyWrapper\.prototype\.(?:dropWhile|reject|slice)\s*=[\s\S]+?\n\1\};\n/gm, '');

  // Remove other `LazyWrapper.prototype` assignments.
  source = source.replace(/^(?: *\/\/.*\n)* *LazyWrapper\.prototype\.[$\w]+\s*=.+?;\n/gm, '');

  // Remove `LazyWrapper` additions to `LodashWrapper`.
  source = source.replace(/^(?: *\/\/.*\n)*( *)baseForOwn\(LazyWrapper\.prototype\b[\s\S]+?\n\1\}\);\n/m, '');

  // Remove related `lodash.prototype` method aliases.
  return source.replace(/^(?: *\/\/.*\n)* *lodash\.prototype\.(?:collect|head|select|tail)\s*=.+?;\n/gm, '');
}

/**
 * Removes metadata optimizations from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @param {Object} [funcDepMap] The function dependency map to modify.
 * @param {Object} [objDepMap] The object dependency map to modify.
 * @param {Object} [varDepMap] The variable dependency map to modify.
 * @returns {string} Returns the modified source.
 */
function removeMetadata(source, funcDepMap, objDepMap, varDepMap) {
  var deps = _.result(funcDepMap, 'baseCallback', []);
  _.pull(deps, 'isBindable');

  deps = _.result(funcDepMap, 'createWrapper', []);
  _.pull(deps, 'baseSetData', 'getData', 'mergeData', 'setData');

  deps = _.result(funcDepMap, 'support', []);
  _.pull(deps, 'isNative');

  deps = _.result(varDepMap, 'support', []);
  _.pull(deps, 'root');

  source = removeSupportProp(source, 'funcDecomp');
  source = removeSupportProp(source, 'funcNames');

  // Remove metadata related code.
  source = source.replace(matchFunction(source, 'baseCallback'), function(match) {
    return match.replace(/\s*&&\s*isBindable\([^)]+\)/, '');
  });

  source = source.replace(matchFunction(source, 'createWrapper'), function(match) {
    match = _.reduce(['data', 'funcBitmask', 'funcIsPartialed', 'setter'], removeVar, match);
    return match
      .replace(/^(?: *\/\/.*\n)*( *)if\s*\((?:typeof\s+)?data\b[\s\S]+?\n\1\}\n/gm, '')
      .replace(/^( *return\s+)setter\(([^,]+),[^)]+\)/m, '$1$2');
  });

  return source;
}

/**
 * Removes the `funcName` function declaration, expression, or assignment and
 * associated code from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @param {string} funcName The name of the function to remove.
 * @returns {string} Returns the modified source.
 */
function removeFunction(source, funcName) {
  source = source == null ? '' : String(source);
  return (funcName == 'runInContext')
    ? removeRunInContext(source, funcName)
    : source.replace(matchFunction(source, funcName, true), '');
}

/**
 * Removes all references to `getGetCallback` from `source` and replaces calls
 * with `baseCallback`.
 *
 * @private
 * @param {string} source The source to process.
 * @param {Object} [funcDepMap] The dependency map to modify.
 * @returns {string} Returns the modified source.
 */
function removeGetCallback(source, funcDepMap) {
  source = removeFunction(source, 'getCallback');

  _.each([
    'createAggregator', 'createExtremum', 'dropRightWhile', 'dropWhile', 'every',
    'filter', 'find','findIndex', 'findKey', 'findLast', 'findLastIndex', 'findLastKey',
    'map', 'mapValues', 'reduce', 'reduceRight', 'reject', 'remove', 'some', 'sortBy',
    'sortedIndex', 'sortedLastIndex', 'takeRightWhile', 'takeWhile', 'transform', 'uniq'
  ], function(funcName) {
    var deps = _.result(funcDepMap, funcName, []);
    _.pull(deps, 'getCallback');
    if (!_.includes(deps, 'baseCallback')) {
      deps.push('baseCallback');
    }
    source = source.replace(matchFunction(source, funcName), function(match) {
      return match.replace(reGetCallback, 'baseCallback');
    });
  });

  _.each(['createExtremum', 'sortedIndex', 'sortedLastIndex', 'uniq'], function(funcName) {
    var isExtremum = funcName == 'createExtremum',
        isSorted = /^sorted/.test(funcName);

    source = source.replace(matchFunction(source, funcName), function(match) {
      match = removeVar(match, 'func');
      if (isSorted) {
        return match
          .replace(/\(func[^)]+\)/, 'iteratee == null')
          .replace(/\bfunc(?=\()/, 'baseCallback');
      }
      return match.replace(/^( *)if\s*\(!\(func[\s\S]+?\n\1\}/m, function(match, indent) {
        return indent +
          'iteratee = ' + (isExtremum ? 'noIteratee' : 'iteratee == null') +
          ' ? iteratee : baseCallback(iteratee, thisArg, 3);';
      });
    });
  });

  return source.replace(getMethodAssignments(source), function(match) {
    _.each(['main', 'wrapperValue'], function(funcName) {
      var deps = _.result(funcDepMap, funcName, []);
      if (_.includes(deps, 'getCallback')) {
        _.pull(deps, 'getCallback').push('baseCallback');
        match = match.replace(reGetCallback, 'baseCallback');
        return false;
      }
    });
    return match;
  });
}

/**
 * Removes all references to `getIndexOf from `source` and replaces calls with
 * `baseIndexOf`.
 *
 * @private
 * @param {string} source The source to process.
 * @param {Object} [funcDepMap] The dependency map to modify.
 * @returns {string} Returns the modified source.
 */
function removeGetIndexOf(source, funcDepMap) {
  source = removeFunction(source, 'getIndexOf');

  _.each(['baseDifference', 'baseUniq', 'includes', 'intersection', 'pull', 'uniq'], function(funcName) {
    var deps = _.result(funcDepMap, funcName, []);
    if (_.includes(deps, 'getIndexOf')) {
      _.pull(deps, 'getIndexOf');
      if (funcName != 'uniq') {
        deps.push('baseIndexOf');
      }
      source = source.replace(matchFunction(source, funcName), function(match) {
        match = replaceVar(match, 'indexOf', 'baseIndexOf');
        return match
          // Replace all `getIndexOf` calls with `baseIndexOf`.
          .replace(/\bgetIndexOf\b(?:\(\))?/g, 'baseIndexOf')
          // Remove "indexOf" comparisons.
          .replace(/\bindexOf\s*==\s*baseIndexOf\b/, 'true')
          .replace(/\s*&&\s*baseIndexOf\s*==\s*baseIndexOf\b/, '');
      });
    }
  });
  return source;
}

/**
 * Removes the copyright/license header from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @returns {string} Returns the modified source.
 */
function removeHeader(source) {
  source = source == null ? '' : String(source);
  return source.replace(getHeader(source), '');
}

/**
 * Removes the `_.isArguments` fork from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @returns {string} Returns the modified source.
 */
function removeIsArgumentsFork(source) {
  source = source == null ? '' : String(source);
  return source.replace(getIsArgumentsFork(source), '');
}

/**
 * Removes the `_.isArray` fork from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @returns {string} Returns the modified source.
 */
function removeIsArrayFork(source) {
  source = source == null ? '' : String(source);
  return source.replace(getIsArrayFork(source), '');
}

/**
 * Removes the `_.isElement` fork from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @returns {string} Returns the modified source.
 */
function removeIsElementFork(source) {
  source = source == null ? '' : String(source);
  return source.replace(getIsElementFork(source), '');
}

/**
 * Removes the `_.isFunction` fork from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @returns {string} Returns the modified source.
 */
function removeIsFunctionFork(source) {
  source = source == null ? '' : String(source);
  return source.replace(getIsFunctionFork(source), '');
}

/**
 * Removes all `isHostObject` references from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @param {Object} [funcDepMap] The dependency map to modify.
 * @returns {string} Returns the modified source.
 */
function removeIsHostObject(source, funcDepMap) {
  source = source == null ? '' : String(source);

  _.each(['baseClone', 'baseIsEqualDeep', 'isElement', 'isNative', 'shimIsPlainObject'], function(funcName) {
    var deps = _.result(funcDepMap, funcName, []);
    _.pull(deps, 'isHostObject');
  });

  _.each(['baseIsEqualDeep', 'shimIsPlainObject'], function(funcName) {
    source = source.replace(matchFunction(source, funcName), function(match) {
      return match.replace(/\s*&&\s*!isHostObject\([^)]+\)/g, '');
    });
  });

  source = source.replace(matchFunction(source, 'baseClone'), function(match) {
    return match.replace(/^(?: *\/\/.*\n)*( *)if\s*\(isHostObject\b[\s\S]+?\n\1\}\n/m, '');
  });

  source = source.replace(matchFunction(source, 'isElement'), function(match) {
    return match.replace(/\(lodash\.support\.nodeTag\s*\?\s*([\s\S]+?)\s*:[\s\S]+?\)\)/, '$1');
  });

  return source.replace(matchFunction(source, 'isNative'), function(match) {
    return match.replace(/\s*\(isHostObject\b[^:]+:([\s\S]+?)\)/, '$1');
  });
}

/**
 * Removes the `@license` tag from the copyright header so minifiers and
 * build optimizers may strip them.
 *
 * @private
 * @param {string} source The source to inspect.
 * @returns {string} Returns the modified source.
 */
function removeLicenseTag(source) {
  source = source == null ? '' : String(source);
  return source.replace(/^ \* *@license\n/m, '');
}

/**
 * Removes a method assignment by name from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @param {string} [methodName] The name of the method assignment to remove.
 * @returns {string} Returns the modified source.
 */
function removeMethodAssignment(source, methodName) {
  source = source == null ? '' : String(source);

  return source.replace(getMethodAssignments(source), function(match) {
    var reAssignment = RegExp(
      '^( *//.*\\n)* *' +
      'lodash(?:\\.prototype)?\\.' +
      '(?:[$\\w]+\\s*=\\s*' + methodName + '|' + methodName + '\\s*=\\s*[$\\w]+);' +
      '\\n(\\n)?'
    , 'gm');

    return match.replace(reAssignment, function(match, comment, newline) {
      return (!newline && comment) || newline || '';
    });
  });
}

/**
 * Removes all lodash method assignments from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @returns {string} Returns the modified source.
 */
function removeMethodAssignments(source) {
  source = source == null ? '' : String(source);
  return source.replace(getMethodAssignments(source), '');
}

/**
 * Removes all `_.mixin` calls from `source`.
 *
 * @private
 * @param {string} source The source to inspect.
 * @returns {string} Returns the modified source.
 */
function removeMixinCalls(source) {
  source = source == null ? '' : String(source);
  return source.replace(/^(?: *\/\/.*\n)*( *)mixin\(.+?(?:\{[\s\S]+?\n\1\}.+?)?\);\n/gm, '');
}

/**
 * Removes the `_.now` fork from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @returns {string} Returns the modified source.
 */
function removeNowFork(source) {
  source = source == null ? '' : String(source);
  return source.replace(getNowFork(source), '');
}

/**
 * Removes the `_.parseInt` fork from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @returns {string} Returns the modified source.
 */
function removeParseIntFork(source) {
  source = source == null ? '' : String(source);
  return source.replace(getParseIntFork(source), '');
}

/**
 * Removes a lodash property, of the given property name, from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @param {string} propName The name of the property to remove.
 * @returns {string} Returns the modified source.
 */
function removeProp(source, propName) {
  source = source == null ? '' : String(source);
  return source.replace(matchProp(source, propName, true), '');
}

/**
 * Removes all `runInContext` references from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @returns {string} Returns the modified source.
 */
function removeRunInContext(source) {
  source = removeVar(source, 'clearTimeout');
  source = removeVar(source, 'contextProps');
  source = removeVar(source, 'setTimeout');
  source = removeMethodAssignment(source, 'runInContext');

  // Remove function scaffolding, leaving most of its content.
  source = source.replace(matchFunction(source, 'runInContext', true), function(match) {
    match = replaceIndent(match, 2, 1);
    return match
      // Remove function frame.
      .replace(/^[\s\S]+?function\s+runInContext\b[\s\S]+?context\s*=\s*context.+?\n+| *return\s+lodash;[\s\S]+$/g, '')
      // Remove native constructor references.
      .replace(/^(?: *\/\*[^*]*\*+(?:[^\/][^*]*\*+)*\/\n)? *var\s+Array\s*=[\s\S]+?;\n/m, '')
      // Replace `reThis` reference in `support.funcDecomp` assignment.
      .replace(/\btest\(runInContext\)/, 'test(function() { return this; })')
      // Replace `context` references with `root`.
      .replace(/\bcontext\b/g, 'root');
  });

  return source
    // Remove `_` assignment.
    .replace(/^(?: *\/\/.*\n)* *var\s+_\s*=\s*runInContext\b.+\n+/m, '')
    // Replace `_` references with `lodash`.
    .replace(/(\breturn\s+|=\s*)_([;)])/g, '$1lodash$2');
}

/**
 * Removes the `support.spliceObjects` fix from the `Array` function mixins
 * snippet of `source`.
 *
 * @private
 * @param {string} source The source to inspect.
 * @returns {string} Returns the modified source.
 */
function removeSpliceObjectsFix(source) {
  source = source == null ? '' : String(source);

  return source.replace(/^( *)arrayEach\(\['concat\b[\s\S]+?\n\1\}\);/m, function(match) {
    match = removeVar(match, 'fixObjects');
    match = removeVar(match, 'func');
    return match.replace(/\barrayFunc\b/g, 'func');
  });
}

/**
 * Removes all strings from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @returns {string} Returns the modified source.
 */
function removeStrings(source) {
  source = source == null ? '' : String(source);
  return source.replace(reStrings, '');
}

/**
 * Removes all `support.argsTag` references from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @param {Object} [funcDepMap] The function dependency map to modify.
 * @param {Object} [objDepMap] The object dependency map to modify.
 * @returns {string} Returns the modified source.
 */
function removeSupportArgsTag(source, funcDepMap, objDepMap) {
  source = removeIsArgumentsFork(source);
  source = removeSupportProp(source, 'argsTag');

  _.each(['isArguments', 'isPlainObject', 'shimIsPlainObject'], function(funcName) {
    var deps = _.result(funcDepMap, funcName, []);
    _.pull(deps, 'isArguments');

    if (funcName != 'shimIsPlainObject') {
      deps = _.result(objDepMap, funcName, []);
      _.pull(deps, 'support');
    }
  });

  _.each(['shimIsPlainObject', 'isPlainObject'], function(funcName) {
    source = source.replace(matchFunction(source, funcName), function(match) {
      return match.replace(/\s*\|\|\s*\(!(?:lodash\.)?support\.argsTag\b[\s\S]+?\)\)/, '');
    });
  });

  return source;
}

/**
 * Removes all `support.dom` references from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @param {Object} [objDepMap] The dependency map to modify.
 * @returns {string} Returns the modified source.
 */
function removeSupportDom(source, objDepMap) {
  var deps = _.result(objDepMap, 'isElement', []);
  _.pull(deps, 'support');

  source = removeSupportProp(source, 'dom');
  return removeIsElementFork(source);
}

/**
 * Removes all `support.enumErrorProps` references from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @returns {string} Returns the modified source.
 */
function removeSupportEnumErrorProps(source) {
  return removeSupportProp(source, 'enumErrorProps');
}

/**
 * Removes all `support.enumPrototypes` references from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @param {Object} [objDepMap] The dependency map to modify.
 * @returns {string} Returns the modified source.
 */
function removeSupportEnumPrototypes(source, objDepMap) {
  var deps = _.result(objDepMap, 'keys', []);
  _.pull(deps, 'support');

  source = removeSupportProp(source, 'enumPrototypes');

  // Remove `support.enumPrototypes` from `_.keys`.
  return source.replace(matchFunction(source, 'keys'), function(match) {
    return match.replace(/typeof\s+object[^:]+:/, "typeof object != 'function' &&");
  });
}

/**
 * Removes all `support.nodeTag` references from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @param {Object} [funcDepMap] The dependency map to modify.
 * @returns {string} Returns the modified source.
 */
function removeSupportNodeTag(source, funcDepMap) {
  var deps = _.result(funcDepMap, 'isElement', []);
  _.pull(deps, 'isHostObject');

  source = removeSupportProp(source, 'nodeTag');

  // Remove `support.nodeTag` from `_.isElement`.
  return source.replace(matchFunction(source, 'isElement'), function(match) {
    return match.replace(/\(lodash\.support\.nodeTag\s*\?\s*([\s\S]+?)\s*:[\s\S]+?\)\)/, '$1');
  });
}

/**
 * Removes all `support.nonEnumArgs` references from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @returns {string} Returns the modified source.
 */
function removeSupportNonEnumArgs(source) {
  return removeSupportProp(source, 'nonEnumArgs');
}

/**
 * Removes all `support.nonEnumShadows` references from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @returns {string} Returns the modified source.
 */
function removeSupportNonEnumShadows(source) {
  return removeSupportProp(source, 'nonEnumShadows');
}

/**
 * Removes all `support.nonEnumStrings` references from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @param {Object} [funcDepMap] The function dependency map to modify.
 * @returns {string} Returns the modified source.
 */
function removeSupportNonEnumStrings(source, funcDepMap) {
  var deps = _.result(funcDepMap, 'shimKeys', []);
  _.pull(deps, 'isString');

  source = removeSupportProp(source, 'nonEnumStrings');

  // Remove `support.nonEnumStrings` from `shimKeys`.
  return source.replace(matchFunction(source, 'shimKeys'), function(match) {
    return match.replace(/\s*\|\|\s*\(support\.nonEnumStrings\b[\s\S]+?\)\)(\s*\|\|\s*)?/, function(match, postlude) {
      return postlude ? postlude.replace(/\s+$/, ' ') : '';
    });
  });
}

/**
 * Removes all `support.ownLast` references from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @returns {string} Returns the modified source.
 */
function removeSupportOwnLast(source) {
  source = removeSupportProp(source, 'ownLast');

  // Remove `support.ownLast` from `shimIsPlainObject`.
  return source.replace(matchFunction(source, 'shimIsPlainObject'), function(match) {
    return match.replace(/^(?: *\/\/.*\n)*( *)if\s*\(support\.ownLast\b[\s\S]+?\n\1\}\n/m, '');
  });
}

/**
 * Removes all `support.spliceObjects` references from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @returns {string} Returns the modified source.
 */
function removeSupportSpliceObjects(source) {
  return removeSpliceObjectsFix(removeSupportProp(source, 'spliceObjects'));
}

/**
 * Removes all `support.unindexedChars` references from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @param {Object} [funcDepMap] The function dependency map to modify.
 * @param {Object} [objDepMap] The object dependency map to modify.
 * @returns {string} Returns the modified source.
 */
function removeSupportUnindexedChars(source, funcDepMap, objDepMap) {
  _.each(['toIterable', 'toArray', 'toObject'], function(funcName) {
    var deps = _.result(funcDepMap, funcName, []);
    _.pull(deps, 'isString');

    deps =  _.result(objDepMap, funcName, []);
    _.pull(deps, 'support');
  });

  source = removeSupportProp(source, 'unindexedChars');

  // Remove `support.unindexedChars` from `toIterable` and `toObject`.
  _.each(['toIterable', 'toObject'], function(funcName) {
    source = source.replace(matchFunction(source, funcName), function(match) {
      return match.replace(/^(?: *\/\/.*\n)*( *)if\s*\(lodash\.support\.unindexedChars\b[\s\S]+?\n\1\}\n/m, '');
    });
  });

  // Remove `support.unindexedChars` from `_.toArray`.
  return source.replace(matchFunction(source, 'toArray'), function(match) {
    return match.replace(/\(lodash\.support\.unindexedChars\b[\s\S]+?:\s*/, '');
  });
}

/**
 * Removes a given property from the `support` object in `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @param {string} varName The name of the `support` property to remove.
 * @returns {string} Returns the modified source.
 */
function removeSupportProp(source, propName) {
  source = source == null ? '' : String(source);
  propName = _.escapeRegExp(propName);

  return source.replace(matchProp(source, 'support'), function(match) {
    return match.replace(RegExp(
      '\\n+' + commentPattern +
      // Match a `try` block.
      '(?:( *)try\\b.+\\n)?' +
      // Match the `support` property assignment.
      ' *support\\.' + propName + '\\s*=[\\s\\S]+?;' +
      // Match the `catch` block.
      '(?:\\n\\1\\}\\s*catch\\b[\\s\\S]+?\\n\\1\\})?'
    , 'm'), '');
  });
}

/**
 * Removes a variable of the given variable name from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @param {string} varName The name of the variable to remove.
 * @returns {string} Returns the modified source.
 */
function removeVar(source, varName) {
  source = source == null ? '' : String(source);

  _.some([
    function(source) {
      return removeFunction(source, varName);
    },
    function(source) {
      return source.replace(matchVar(source, varName, true), '');
    }
  ], function(func) {
    var result = func(source);
    if (result !== source) {
      source = result;
      return true;
    }
  });
  return source;
}

/**
 * Replaces the `funcName` function body in `source` with `funcValue`.
 *
 * @private
 * @param {string} source The source to process.
 * @param {string} funcName The name of the function to replace.
 * @param {string} funcValue The replacement value.
 * @returns {string} Returns the modified source.
 */
function replaceFunction(source, funcName, funcValue) {
  source = source == null ? '' : String(source);

  var checkFuncTag = reVarSnippet.test(funcValue),
      snippet = matchFunction(source, funcName, checkFuncTag);

  if (!snippet) {
    return source;
  }
  return source.replace(snippet, function(match) {
    var header = checkFuncTag ? getHeader(match) : '';
    if (header && !isFunctionSnippet(snippet)) {
      header = header.replace(/^( *)\* *(?:@(?:category|param|returns)\b|\/)/m, function(match, indent) {
        return indent + '* @type Function\n' + match;
      });
    }
    return header + funcValue
      .replace(RegExp('^' + getIndent(funcValue), 'gm'), getIndent(snippet))
      .trimRight() + '\n';
  });
}

/**
 * Replaces the IIFE that wraps `source` with `iife`. If the `%output%` token
 * is present in `iife` it will be replaced with the unwrapped `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @param {string} iife The replacement IIFE.
 * @returns {string} Returns the modified source.
 */
function replaceIIFE(source, iife) {
  source = source == null ? '' : String(source);
  iife = iife == null ? '' : String(iife);

  var token = '%output%',
      header = getHeader(source),
      index = iife.indexOf(token);

  if (index < 0) {
    return header + iife;
  }
  return header +
    iife.slice(0, index) +
    source.replace(/^[\s\S]+?\(function[^{]+\{\n+|\s*\}\.call\(this\)\)[;\s]*$/g, '\n') +
    iife.slice(index + token.length);
}

/**
 * Replaces the indent at level `from` of the given source with the level `to`.
 *
 * @private
 * @param {string} source The source to process.
 * @param {number} from The indent level to be replaced.
 * @param {number} to The indent level to replace with.
 * @returns {string} Returns the modified source.
 */
function replaceIndent(source, from, to) {
  source = source == null ? '' : String(source);
  return source.replace(RegExp('^(?:  ){' + (from || 1) + '}', 'gm'), _.repeat('  ', to));
}

/**
 * Replaces the `support` object `propName` property value in `source` with `propValue`.
 *
 * @private
 * @param {string} source The source to process.
 * @param {string} varName The name of the `support` property to replace.
 * @returns {string} Returns the modified source.
 */
function replaceSupportProp(source, propName, propValue) {
  source = source == null ? '' : String(source);
  propName = _.escapeRegExp(propName);

  return source.replace(RegExp(
    // Match a `try` block.
    '^(?: *try\\b.+\\n)?' +
    // Match the `support` property assignment.
    '( *support\\.' + propName + '\\s*=).+\\n' +
    // Match the `catch` block.
    '(?:( *).+?catch\\b[\\s\\S]+?\\n\\2\\}\\n)?'
  , 'm'), function(match, left) {
    return left + ' ' + propValue + ';\n';
  });
}

/**
 * Replaces the `varName` variable declaration value in `source` with `varValue`.
 *
 * @private
 * @param {string} source The source to inspect.
 * @param {string} varName The name of the variable to replace.
 * @param {string} varValue The replacement value.
 * @returns {string} Returns the modified source.
 */
function replaceVar(source, varName, varValue) {
  source = source == null ? '' : String(source);
  varName = _.escapeRegExp(varName);

  // Replace a variable that's not part of a declaration list.
  var result = source.replace(RegExp(
    '(( *)var\\s+' + varName + '\\s*=)' +
    '(?:.+?;|(?:Function\\(.+?|.*?[^,])\\n[\\s\\S]+?\\n\\2.+?;)\\n'
  ), function(match, left) {
    return left + ' ' + varValue + ';\n';
  });

  if (source == result) {
    // Replace a varaible at the start or middle of a declaration list.
    result = source.replace(RegExp('((?:var|\\n)\\s+' + varName + '\\s*=).+?(?=,\\n)'), function(match, left) {
      return left + ' ' + varValue;
    });
  }
  if (source == result) {
    // Replace a variable at the end of a variable declaration list.
    result = source.replace(RegExp('(,\\s*' + varName + '\\s*=).+?(?=;\\n)'), function(match, left) {
      return left + ' ' + varValue;
    });
  }
  return result;
}

/**
 * Add or remove the "use strict" directive from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @param {boolean} value The value to set.
 * @returns {string} Returns the modified source.
 */
function setUseStrictOption(source, value) {
  source = source == null ? '' : String(source);
  return source.replace(/^([\s\S]*?function[^{]+\{)(?:\s*'use strict';)?/, '$1' + (value ? "\n  'use strict';" : ''));
}

/**
 * This function allows `callback` to modify `source` with string literals
 * removed and returns the modified source with string literals restored.
 *
 * @private
 * @param {string} source The source to modify.
 * @param {Function} [callback] The function to modify the string free source.
 * @returns {string} Returns the modified source.
 */
function stringFree(source, callback) {
  source = source == null ? '' : String(source);

  var strings = [];
  source = callback(source.replace(reStrings, function(match) {
    strings.push(match);
    return stringToken;
  })) || '';

  return source.replace(reStringTokens, function() {
    return strings.shift();
  });
}

/**
 * Trims the indent of the specified level from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @param {number} level The level of indent to trim.
 * @returns {string} Returns the modified source.
 */
function trimIndent(source, level) {
  return replaceIndent(source, level || 1);
}

/*----------------------------------------------------------------------------*/

/**
 * Creates a debug and/or minified build, invoking the callback for each. The
 * `callback` is invoked with one argument; (data).
 *
 * Note: For a list of commands see `HELP_TEXT` or run `lodash --help`.
 *
 * @param {Array|Object} [options=[]] An array of build commands or the state object.
 * @param {Function} [callback=defaultBuildCallback] The function called per build.
 */
function build(options, callback) {
  options || (options = []);
  callback || (callback = defaultBuildCallback);

  // Used to specify the output path for builds.
  var outputPath;

  // Used to specify the source map URL.
  var sourceMapURL;

  // Used to pre-populate the build state.
  var state = _.isPlainObject(options) && options;

  var isExcluded = function() {
    return _.every(arguments, _.negate(_.partial(_.includes, buildFuncs, _, 0)));
  };

  if (state) {
    var buildFuncs = state.buildFuncs,
        filePath = state.filePath,
        funcDepMap = state.funcDepMap,
        includeFuncs = state.includeFuncs,
        includeObjs = state.includeObjs,
        includeVars = state.includeVars,
        isDevelopment = true,
        isModularize = true,
        isStdOut = state.isStdOut,
        isStrict = state.isStrict,
        minusFuncs = [],
        objDepMap = state.objDepMap,
        outputPath = state.outputPath,
        plusFuncs = [],
        source = state.source,
        varDepMap = state.varDepMap;
  }
  else {
    // Clone dependencies to modify.
    var funcDepMap = createMap(_.cloneDeep(funcDependencyMap)),
        objDepMap = createMap(_.cloneDeep(objDependencyMap)),
        varDepMap = createMap(_.cloneDeep(varDependencyMap));

    // The path to the source file.
    var filePath = require.resolve('lodash-compat');

    // Used to specify a custom IIFE to wrap lodash.
    var iife = getOption(options, 'iife');

    // Used to match external template files to precompile.
    var templatePattern = getOption(options, 'template', '');

    // Used as the template settings for precompiled templates.
    var templateSettings = (function() {
      var result = getOption(options, 'settings');
      return result
        ? Function('return {' + result.replace(/^\{|\}$/g, '') + '}')()
        : _.clone(_.templateSettings);
    }());

    // A flag to specify only creating the development build.
    var isDevelopment = getOption(options, '-d') || getOption(options, '--development');

    // A flag to indicate that a custom IIFE was specified.
    var isIIFE = typeof iife == 'string';

    // A flag to specify creating a source map for the minified source.
    var isMapped = getOption(options, '-m') || getOption(options, '--source-map');

    // A flag to specify a modern build.
    var isModern = getOption(options, 'modern');

    // A flag to specify a modularize build.
    var isModularize = getOption(options, 'modularize');

    // A flag to specify only creating the minified build.
    var isProduction = getOption(options, '-p') || getOption(options, '--production');

    // A flag to specify writing output to standard output.
    var isStdOut = getOption(options, '-c') || getOption(options, '--stdout');

    // A flag to specify skipping status updates normally logged to the console.
    var isSilent = !isBin || isStdOut || getOption(options, '-s') || getOption(options, '--silent');

    // A flag to specify `_.assign`, `_.bindAll`, and `_.defaults`
    // are constructed using the "use strict" directive.
    var isStrict = getOption(options, 'strict');

    // A flag to specify a template build.
    var isTemplate = !!templatePattern;

    // Used to specify the ways to export the `lodash` function.
    var exportsOptions = (function() {
      var result = getOption(options, 'exports', isModularize ? ['amd'] : defaultExports);
      return isModularize ? _.take(result, 1) : result;
    }());

    // Used to specify the AMD module ID of lodash used by precompiled templates.
    var moduleId = getOption(options, 'moduleId', null);

    // Used as the output path for the build.
    var outputPath = _.reduce(options, function(result, value, index) {
      return /^(?:-o|--output)$/.test(value)
        ? path.normalize(options[index + 1])
        : result;
    }, isModularize ? '.' + path.sep + 'modularize' : '');

    // A flag to specify creating a custom build.
    var isCustom = !isModularize && (
      isMapped || isModern || isStrict || isTemplate || outputPath ||
      getOption(options, 'compat') ||
      /\b(?:category|exports|iife|include|minus|moduleId|plus)=/.test(options) ||
      !_.isEqual(exportsOptions, defaultExports)
    );

    // Flags to specify export options.
    var isAMD = _.includes(exportsOptions, 'amd'),
        isCommonJS = _.includes(exportsOptions, 'commonjs'),
        isES = _.includes(exportsOptions, 'es') || _.includes(exportsOptions, 'es6'),
        isGlobal = _.includes(exportsOptions, 'global'),
        isNpm = _.includes(exportsOptions, 'npm'),
        isNode = isNpm || _.includes(exportsOptions, 'iojs') || _.includes(exportsOptions, 'node');

    if (isES) {
      _.pull(exportsOptions, 'es', 'es6').push('es');
    }
    if (isNode) {
      _.pull(exportsOptions, 'iojs', 'node').push('node');
    }
    // The lodash.js source.
    var source = fs.readFileSync(filePath, 'utf8');

    /*------------------------------------------------------------------------*/

    // Categories of functions to include in the build.
    var categoryOptions = _.map(getOption(options, 'category', []), function(category) {
      return getRealCategory(_.capitalize(category.toLowerCase()));
    });

    // Functions to include in the build.
    var includeFuncs = _.union(categoryOptions, _.map(getOption(options, 'include', []), getRealName));

    // Properties to include in the build.
    var includeObjs = _.intersection(includeFuncs, objDependencies);

    // Variables to include in the build.
    var includeVars = _.intersection(includeFuncs, varDependencies);

    // Functions to remove from the build.
    var minusFuncs = _.map(getOption(options, 'minus', []), getRealName);

    // Functions to add to the build.
    var plusFuncs = _.map(getOption(options, 'plus', []), getRealName);

    // Expand categories to function names.
    _.each([includeFuncs, minusFuncs, plusFuncs], function(funcNames) {
      var categories = _.intersection(funcNames, allCategories);

      _.each(categories, function(category) {
        push.apply(funcNames, _.filter(getNamesByCategory(category), function(key) {
          var type = typeof _[key];
          return type == 'function' || type == 'undefined';
        }));
      });
    });

    // Remove categories from function names.
    includeFuncs = _.difference(includeFuncs, allCategories, includeObjs, includeVars);
    minusFuncs = _.difference(minusFuncs, allCategories);
    plusFuncs = _.difference(plusFuncs, allCategories);

    /*------------------------------------------------------------------------*/

    // Used to capture warnings for invalid command-line arguments.
    var warnings = [];

    // Used to detect invalid command-line arguments.
    var invalidArgs = _.reject(options, function(value, index, options) {
      if (/^(?:-o|--output)$/.test(options[index - 1]) ||
          /^(?:category|exports|iife|include|moduleId|minus|plus|settings|template)=[\s\S]*$/.test(value)) {
        return true;
      }
      var result = _.includes([
        'compat',
        'modern',
        'modularize',
        'strict',
        '-c', '--stdout',
        '-d', '--development',
        '-h', '--help',
        '-m', '--source-map',
        '-o', '--output',
        '-p', '--production',
        '-s', '--silent',
        '-V', '--version'
      ], value);

      if (!result && /^(?:-m|--source-map)$/.test(options[index - 1])) {
        sourceMapURL = value;
        return true;
      }
      return result;
    });

    // Report invalid command and option arguments.
    if (!_.isEmpty(invalidArgs)) {
      warnings.push('Invalid argument' + (_.size(invalidArgs) > 1 ? 's' : '') + ' passed: ' + invalidArgs.join(', '));
    }
    // Report invalid command combinations.
    invalidArgs = _.intersection(options, ['compat', 'modern']);

    if (isTemplate) {
      invalidArgs.push('template');
    }
    if (_.size(invalidArgs) > 1) {
      warnings.push('The `' + invalidArgs.slice(0, -1).join('`, `') + '`' + (_.size(invalidArgs) > 2 ? ',' : '') + ' and `' + invalidArgs.slice(-1) + '` commands may not be combined.');
    }
    // Report invalid command entries.
    _.forOwn({
      'category': {
        'entries': categoryOptions,
        'validEntries': allCategories
      },
      'exports': {
        'entries': exportsOptions,
        'validEntries': isModularize
          ? _.without(defaultExports.concat(['es', 'npm']), 'global')
          : defaultExports
      },
      'include': {
        'entries': includeFuncs,
        'validEntries': allFuncs
      },
      'minus': {
        'entries': minusFuncs,
        'validEntries': allFuncs
      },
      'plus': {
        'entries': plusFuncs,
        'validEntries': allFuncs
      }
    }, function(data, commandName) {
      invalidArgs = _.difference(data.entries, data.validEntries, ['none']);
      if (!_.isEmpty(invalidArgs)) {
        warnings.push('Invalid `' + commandName + '` entr' + (_.size(invalidArgs) > 1 ? 'ies' : 'y') + ' passed: ' + invalidArgs.join(', '));
      }
    });

    if (!_.isEmpty(warnings)) {
      var warnText = [
        '',
        warnings,
        'For more information type: lodash --help'
      ].join('\n');

      if (isBin) {
        console.warn(warnText);
        process.exit(1);
      } else {
        callback(_.create(Error.prototype, { 'message': warnText, 'source': warnText }));
      }
      return;
    }
    // Display the help message.
    if (getOption(options, '-h') || getOption(options, '--help')) {
      if (isBin) {
        console.log(HELP_TEXT);
      } else {
        callback({ 'source': HELP_TEXT });
      }
      return;
    }
    // Display the `lodash.VERSION`.
    if (getOption(options, '-V') || getOption(options, '--version')) {
      if (isBin) {
        console.log(_.VERSION);
      } else {
        callback({ 'source': _.VERSION });
      }
      return;
    }

    /*------------------------------------------------------------------------*/

    // The names of functions to include in the build.
    var buildFuncs = !isTemplate && (function() {
      source = setUseStrictOption(source, isStrict);

      if (isModularize) {
        if (isNode) {
          _.forOwn(varDepMap, function(depNames) {
            _.pull(depNames, 'root');
          });
          delete varDepMap.root;
        }
        // Add deps to wrap `_.mixin` in `main`.
        funcDepMap.main.push('baseFunctions', 'isObject', 'keys');

        // Remove `lodash` from function deps.
        _.each(placeholderFuncs.concat('mixin'), function(funcName) {
          _.pull(funcDepMap[funcName], 'lodash');
        });
      }
      else {
        funcDepMap.chain.push('wrapperChain');
        funcDepMap.wrapperValue = _.union(funcDepMap.wrapperValue, funcDepMap.main);
        objDepMap.wrapperValue = _.union(objDepMap.wrapperValue, objDepMap.main);

        // Add `arrayEach` to functions with placeholder support because it's
        // used to reduce code for placeholder assignments
        _.each(placeholderFuncs, function(funcName) {
          funcDepMap[funcName].push('arrayEach');
        });

        // Associate "Chain" methods with `wrapperValue`.
        _.each(_.without(categoryMap.Chain, 'lodash', 'wrapperValue'), function(funcName) {
          funcDepMap.wrapperValue.push(funcName);
          funcDepMap[funcName].push('wrapperValue');
        });
      }
      if (isModern) {
        source = removeSupportSpliceObjects(source);

        // Simplify `initCloneByTag`.
        _.pull(varDepMap.initCloneByTag, 'root');

        source = source.replace(matchFunction(source, 'initCloneByTag'), function(match) {
          return match.replace(/^(?: *\/\/.*\n)*( *)if\s*\(Ctor\s+instanceof\s+Ctor[\s\S]+?\n\1\}\n/m, '');
        });

        // Replace `_.isRegExp`.
        _.pull(funcDepMap.isRegExp, 'isObject').push('isObjectLike');

        source = replaceFunction(source, 'isRegExp', [
          'function isRegExp(value) {',
          '  return (isObjectLike(value) && objToString.call(value) == regexpTag) || false;',
          '}'
        ].join('\n'));

        source = removeIsHostObject(source, funcDepMap);
        source = removeSupportArgsTag(source, funcDepMap, objDepMap);
        source = removeSupportEnumErrorProps(source);
        source = removeSupportEnumPrototypes(source, objDepMap);
        source = removeSupportNodeTag(source, funcDepMap);
        source = removeSupportNonEnumShadows(source);
        source = removeSupportNonEnumStrings(source, funcDepMap);
        source = removeSupportOwnLast(source);
        source = removeSupportUnindexedChars(source, funcDepMap, objDepMap);

        _.pull(objDepMap.shimIsPlainObject, 'support');

        // Replace `_.keysIn`.
        _.pull(funcDepMap.keysIn, 'arrayEach', 'isString');

        source = replaceFunction(source, 'keysIn', [
          'function keysIn(object) {',
          '  if (object == null) {',
          '    return [];',
          '  }',
          '  if (!isObject(object)) {',
          '    object = Object(object);',
          '  }',
          '  var length = object.length;',
          '  length = (length && isLength(length) &&',
          '    (isArray(object) || (support.nonEnumArgs && isArguments(object))) && length) || 0;',
          '',
          '  var Ctor = object.constructor,',
          '      index = -1,',
          "      isProto = typeof Ctor == 'function' && Ctor.prototype == object,",
          '      result = Array(length),',
          '      skipIndexes = length > 0;',
          '',
          '  while (++index < length) {',
          "    result[index] = (index + '');",
          '  }',
          '  for (var key in object) {',
          '    if (!(skipIndexes && isIndex(key, length)) &&',
          "        !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {",
          '      result.push(key);',
          '    }',
          '  }',
          '  return result;',
          '}'
        ].join('\n'));
      }
      if (isModularize) {
        source = removeGetIndexOf(source, funcDepMap);
        source = removeGetCallback(source, funcDepMap);
      }
      if (isNpm) {
        source = removeMetadata(source, funcDepMap, objDepMap, varDepMap);
      }
      // Remove "_.matches" or "_.property" style callback support from `baseCallback`.
      _.each(['matches', 'property'], function(funcName) {
        if (_.includes(minusFuncs, funcName)) {
          var baseName = 'base' + _.capitalize(funcName);

          _.pull(funcDepMap.baseCallback, baseName);
          source = source.replace(matchFunction(source, 'baseCallback'), function(match) {
            return match.replace(RegExp('\\b' + baseName + '\\([\\s\\S]+?\\)(?=[;\\n])', 'm'), 'identity');
          });

          if (funcName == 'matches') {
            _.pull(funcDepMap.callback, 'isObjectLike', 'matches');
            source = source.replace(matchFunction(source, 'callback'), function(match) {
              return match.replace(/^( *return\s+)[^:]+:\s*/m, '$1');
            });
          }
        }
      });

      // Add function names explicitly.
      if (!_.isEmpty(includeFuncs)) {
        var result = includeFuncs;
      }
      // Add default function names.
      if (_.isEmpty(includeObjs) && _.isEmpty(includeVars) && !result) {
        result = _.clone(lodashFuncs);
      }
      // Remove special "none" entry.
      if (result == 'none') {
        result = [];
      } else {
        _.pull(result, 'none');
      }
      // Add and subtract function names.
      if (!_.isEmpty(plusFuncs)) {
        result = _.union(result, plusFuncs);
      }
      if (!_.isEmpty(minusFuncs)) {
        result = _.difference(result, minusFuncs.concat(getDependants(minusFuncs, funcDepMap, true)));
      }
      if (isModularize) {
        _.pull(result, 'noConflict', 'runInContext');
      }
      return getDependencies(result, funcDepMap, true);
    }());

    // Expand properties, variables, and their function dependencies to include in the build.
    var allDeps = getAllDependencies(buildFuncs, funcDepMap, objDepMap, varDepMap).sort();
    buildFuncs = _.intersection(allFuncs, allDeps);
    includeObjs = _.intersection(objDependencies, allDeps);
    includeVars = _.intersection(varDependencies, allDeps);

    /*------------------------------------------------------------------------*/

    // Load customized lodash module.
    var lodash = !isTemplate && (function() {
      var context = vm.createContext({
        'clearTimeout': clearTimeout,
        'console': console,
        'setTimeout': setTimeout
      });

      vm.runInContext(source, context);
      return context._;
    }());

    /*------------------------------------------------------------------------*/

    if (isTemplate) {
      source = buildTemplate({
        'moduleId': moduleId,
        'source': source,
        'templatePattern': templatePattern,
        'templateSettings': templateSettings
      });
    }
    else if (isModularize) {
      // Unexpose `lodash.support`.
      _.forOwn(objDependencyMap, function(deps, funcName) {
        if (_.includes(deps, 'support')) {
          source = source.replace(matchFunction(source, funcName), function(match) {
            return removeVar(match, 'support');
          });
        }
      });

      source = source
        .replace(/\blodash\.support\s*=\s*/, '')
        .replace(/\blodash\.(?=support\b)/g, '');

      // Replace the `lodash.templateSettings` property assignment with a variable assignment.
      source = source.replace(/\b(lodash\.)(?=templateSettings\s*=)/, 'var ');

      // Remove the `lodash` namespace from properties.
      source = source.replace(/( *)lodash\.([$\w]+\.)?([$\w]+)(\s*=\s*(?:function\([\s\S]+?\n\1\}|.+?);\n)?/g, function(match, indent, property, identifier, right) {
        return (property || right || identifier == 'com' || identifier == 'prototype')
          ? match
          : (indent + identifier);
      });

      // Remove all horizontal rule comment separators.
      source = source.replace(/^ *\/\*-+\*\/\n/gm, '');

      // Remove `lodash` branch in `_.mixin`.
      source = source.replace(matchFunction(source, 'mixin'), function(match) {
        match = match.replace(/^(?: *\/\/.*\n)*( *)if\s*\(options\s*==\s*null\b[\s\S]+?\n\1\}\n/m, '');
        return match.replace(/^(?: *\/\/.*\n)*( *)if\s*\(!methodNames\b[\s\S]+?\n\1\}/m, function(match, indent) {
          return indent + 'var methodNames = baseFunctions(source, keys(source));\n';
        });
      });

      // Replace `sample` references in `lodash.prototype.sample` method with `collection.sample`.
      source = source.replace(getMethodAssignments(source), function(match) {
        return match.replace(/^( *)lodash\.prototype\.sample\s*=[\s\S]+?\n\1\}/m, function(match) {
          return match.replace(/\bsample(?=\()/g, 'collection.sample');
        });
      });

      // Replace `lodash` use in `_.templateSettings.imports`.
      source = source.replace(matchProp(source, 'templateSettings'), function(match) {
        return match.replace(/(:\s*)lodash\b/, "$1{ 'escape': escape }");
      });

      source = source.replace(matchFunction(source, 'template'), function(match) {
        // Assign `settings` using `template.imports`.
        match = match.replace(/=\s*templateSettings(?=[,;])/, '$&.imports._.templateSettings || templateSettings');

        // Remove default `sourceURL` value.
        return match.replace(matchVar(match, 'sourceURL'), function(match) {
          return match.replace(/=[\s\S]+?(?=;\n$)/, "= 'sourceURL' in options ? '//# sourceURL=' + options.sourceURL + '\\n' : ''");
        });
      });

      if (isNode) {
        source = source.replace(/\bcontext(?=\.)/g, 'global');
      }
      if (!isAMD) {
        source = removeVar(source, 'undefined');
      }
      source = removeRunInContext(source);
    }

    /*------------------------------------------------------------------------*/

    // Set the AMD module ID.
    if (isAMD && !isModularize && !isTemplate && moduleId != null && moduleId != 'none') {
      source = source.replace(/^ *define\((?=function)/m, "$&'" + moduleId + "', ");
    }
    // Customize lodash's export bootstrap.
    if (!isAMD || isModularize) {
      source = source.replace(/^(?: *\/\/.*\n)*( *)if\s*\(typeof\s+define\b[\s\S]+?else\s+/m, '$1');
    }
    if (!isNode || isModularize) {
      source = source.replace(/^(?: *\/\/.*\n)*( *)if\s*\(moduleExports\b[\s\S]+?else\s*\{([\s\S]+?\n)\1\}\n+/m, '$1$2');
    }
    if (!isCommonJS || isModularize) {
      source = source.replace(/^(?: *\/\/.*\n)*(?:(( *)\}?)\s*else\s*\{)?\s*freeExports\.[$\w]+\s*=[\s\S]+?(?:\n\2\})?\n+/m, function(match, prelude) {
        return _.trim(prelude) ? prelude + '\n' : '';
      });
    }
    if (!isGlobal || isModularize) {
      source = source.replace(/^(?: *\/\/.*\n)*(?:(( *)\}?)\s*else(?:\s*if\s*\(_\))?\s*\{)?(?:\s*\/\/.*)*\s*(?:root\._|_\.templates)\s*=[\s\S]+?(?:\n\2\})?\n+/gm, function(match, prelude) {
        return _.trim(prelude) ? prelude + '\n' : '';
      });
    }
    // Remove `if (freeExports && freeModule) {...}` if it's empty.
    if (isAMD && isGlobal) {
      source = source.replace(/^(?: *\/\/.*\n)* *(?:else\s+)?if\s*\(freeExports.*?\)\s*\{\s*\}\n+/m, '');
    } else {
      source = source.replace(/^(?: *\/\/.*\n)* *(?:else\s+)?if\s*\(freeExports.*?\)\s*\{\s*\}(?:\s*else\s*\{([\s\S]+?\n)\s*\})?\n+/m, '$1');
    }

    /*------------------------------------------------------------------------*/

    // Exit early to create modules.
    if (isModularize) {
      if (callback == defaultBuildCallback) {
        callback = null;
      }
      buildModule({
        'buildFuncs': buildFuncs,
        'filePath': filePath,
        'funcDepMap': funcDepMap,
        'includeFuncs': includeFuncs,
        'includeObjs': includeObjs,
        'includeVars': includeVars,
        'isAMD': isAMD,
        'isCommonJS': isCommonJS,
        'isES': isES,
        'isModern': isModern,
        'isNode': isNode,
        'isNpm': isNpm,
        'isSilent': isSilent,
        'isStdOut': isStdOut,
        'isStrict': isStrict,
        'lodash': lodash,
        'minusFuncs': minusFuncs,
        'objDepMap': objDepMap,
        'options': options,
        'outputPath': outputPath,
        'plusFuncs': plusFuncs,
        'source': source,
        'varDepMap': varDepMap
      }, callback);
      return;
    }
  }

  /*--------------------------------------------------------------------------*/

  // Modify/remove references to removed functions/variables.
  if (!isTemplate) {
    _.each(['MapCache', 'SetCache'], function(funcName) {
      if (isExcluded(funcName)) {
        // Remove prototype assignments.
        source = source.replace(RegExp('^(?: *\\/\\/.*\\n)* *' + funcName + '\\.prototype(?:\\.[$\\w]+|\\[\'[^\']+\'\\])\\s*=.+?;\\n', 'gm'), '');
      }
    });

    if (isExcluded('lodash')) {
      // Remove `LodashWrapper.prototype` assignment.
      source = source.replace(/^(?: *\/\/.*\n)* *LodashWrapper\.prototype\s*=.+\n/m, '');
    }
    if (isExcluded('memoize')) {
      // Remove `memoize.Cache` assignment.
      source = source.replace(/^(?: *\/\/.*\n)* *memoize\.Cache\s*=.+?;\n/m, '');
    }
    if (isExcluded(isModularize ? 'main' : 'mixin')) {
      source = removeMixinCalls(source);
    }
    if (isExcluded(isModularize ? 'main' : 'wrapperValue')) {
      source = removeChaining(source);
    }
    if (isModularize) {
      if (isExcluded('main')) {
        source = removeAssignments(source);
      }
    }
    else if (isExcluded('wrapperValue')) {
      source = removeChaining(source);
    }
    if (_.includes(includeObjs, 'support') && !_.isEmpty(buildFuncs)) {
      if (isExcluded('isArguments', 'isPlainObject', 'shimIsPlainObject')) {
        source = removeSupportArgsTag(source);
      }
      if (isExcluded('isElement')) {
        source = removeSupportNodeTag(source);
      }
      if (isExcluded('isArguments')) {
        source = replaceSupportProp(source, 'argsTag', 'true');
      }
      if (isExcluded('isElement')) {
        source = removeSupportDom(source);
      }
      if (isExcluded('isPlainObject')) {
        source = removeSupportOwnLast(source);
      }
      if (isExcluded('keysIn')) {
        source = removeSupportNonEnumShadows(source);
      }
      if (isExcluded('keysIn', 'shimKeys')) {
        source = removeSupportNonEnumArgs(source);
        source = removeSupportNonEnumStrings(source);
      }
    }
    // Remove functions from the build.
    _.each(allFuncs, function(funcName) {
      if (!_.includes(buildFuncs, funcName) &&
          !(funcName == 'lodash' && !isModularize)) {
        source = removeFunction(source, funcName);
        if (!isModularize) {
          source = removeMethodAssignment(source, funcName);
        }
      }
    });

    // Remove forks of removed functions.
    _.forOwn({
      'bufferClone': removeBufferCloneFork,
      'isArguments': removeIsArgumentsFork,
      'isArray': removeIsArrayFork,
      'isElement': removeIsElementFork,
      'isFunction': removeIsFunctionFork,
      'now': removeNowFork,
      'parseInt': removeParseIntFork
    },
    function(removeFork, funcName) {
      if (isExcluded(funcName)) {
        source = removeFork(source);
      }
    });

    // Remove unneeded property dependencies.
    _.each(objDependencies, function(propName) {
      if (!_.includes(includeObjs, propName)) {
        source = removeProp(source, propName);
      }
    });

    // Remove placeholder assignments of removed functions.
    source = source.replace(/^((?: *\/\/.*\n)*)( *)(arrayEach\(\[')bind\b[\s\S]+?('\][\s\S]+?\n\2\}\))/m, function(match, comment, indent, prelude, postlude) {
      var funcNames = _.reject(placeholderFuncs, isExcluded),
          length = funcNames.length;

      if (length > 1) {
        return (comment + indent + prelude + funcNames.join("', '") + postlude);
      }
      return length
        ? (comment + indent + funcNames[0] + '.placeholder = ') + (isModularize ? '{}' : 'lodash')
        : '';
    });

    // Remove code used to resolve unneeded `support` properties.
    source = source.replace(matchProp(source, 'support'), function(match) {
      return match.replace(/^ *\(function\(x\)[^{]+\{\n(( *)var\s+Ctor\s*=[\s\S]+?\n *for\b[\s\S]+?\}\n)([\s\S]+?)\}\(0,\s*0\)\);\n/m, function(match, setup, indent, body) {
        var modified = setup;

        if (!/\.spliceObjects\s*=\s*(?!false|true)/.test(body)) {
          modified = removeVar(modified, 'object');
        }
        if (!/\.enumPrototypes\s*=\s*(?!false|true)/.test(body) &&
            !/\.nonEnumShadows\s*=\s*(?!false|true)/.test(body) &&
            !/\.ownLast\s*=\s*(?!false|true)/.test(body)) {
          modified = removeVar(modified, 'Ctor');
          modified = removeVar(modified, 'props');
          modified = modified
            .replace(/^ *Ctor\.prototype\b[\s\S]+?;\n/m, '')
            .replace(/^ *for\s*\(var\s+key\b[\s\S]+?\}\n/m, '');
        }
        // If there's no setup code then remove the IIFE.
        return (_.trim(modified) || /\barguments\b/.test(body))
          ? match.replace(setup, modified)
          : body.replace(RegExp('^' + indent, 'gm'), indent.slice(0, -2));
      });
    });

    // Remove unneeded variable dependencies.
    if (!_.includes(includeVars, 'root')) {
      source = removeVar(source, 'freeGlobal');
    }
    if (isModularize) {
      _.each(varDependencies, function(varName) {
        if (!_.includes(includeFuncs, varName) &&
            !_.includes(includeObjs, varName) &&
            !_.includes(includeVars, varName)) {
          source = removeVar(source, varName);
        }
      });
    }
    (function() {
      var useMap = createMap(),
          snippet = cleanupSource(removeStrings(removeComments(source))),
          varNames = _.without(_.difference(getVars(snippet), includeFuncs, includeObjs, includeVars), 'freeGlobal');

      // Remove unused variables.
      while (varNames.length) {
        varNames = _.sortBy(varNames, function(varName) {
          var result = isVarUsed(snippet, varName);
          useMap[varName] = result;
          return result;
        });

        if (useMap[varNames[0]]) {
          varNames.shift();
        }
        else {
          while (varNames.length && !useMap[varNames[0]]) {
            snippet = removeVar(snippet, varNames[0]);
            source = removeVar(source, varNames[0]);
            varNames.shift();
          }
        }
      }
    }());
  }

  // Customize lodash's IIFE.
  if (isIIFE) {
    source = replaceIIFE(source, iife);
  }

  /*--------------------------------------------------------------------------*/

  source = cleanupSource(source);

  // A flag to track if `outputPath` has been used by `callback`.
  var outputUsed = false;

  // Expand `outputPath` and create directories if needed.
  if (outputPath) {
    outputPath = (function() {
      var dirname = path.dirname(outputPath);
      fs.mkdirpSync(dirname);
      return path.join(fs.realpathSync(dirname), path.basename(outputPath));
    }());
  }
  // Resolve the basename of the output path.
  var basename = filePath = outputPath;
  if (!basename) {
    basename = 'lodash';
    if (isTemplate) {
      basename += '.templates';
    } else if (isCustom) {
      basename += '.custom';
    }
    filePath =  path.join(cwd, basename + '.js');
  }
  // Output development build.
  if (!isProduction && (isCustom || isDevelopment || isTemplate)) {
    var devSource = source;
    if (isCustom) {
      devSource = addCommandsToHeader(devSource, options);
    }
    if (isDevelopment && isStdOut) {
      stdout.write(devSource);
      callback({
        'source': devSource
      });
    }
    else if (!isStdOut) {
      outputUsed = true;
      callback({
        'source': devSource,
        'outputPath': filePath
      });
    }
  }
  // Begin the minification process.
  if (!isDevelopment) {
    if (outputPath && outputUsed) {
      outputPath = path.join(path.dirname(outputPath), path.basename(outputPath, '.js') + '.min.js');
    } else if (!outputPath) {
      outputPath = path.join(cwd, basename + '.min.js');
    }
    minify(source, {
      'filePath': filePath,
      'isMapped': isMapped,
      'isSilent': isSilent,
      'isTemplate': isTemplate,
      'modes': isIIFE ? ['simple', 'hybrid'] : ['simple', 'advanced', 'hybrid'],
      'outputPath': outputPath,
      'sourceMapURL': sourceMapURL,
      'onComplete': function(data) {
        if (isCustom) {
          data.source = addCommandsToHeader(data.source, options);
        }
        if (isStdOut) {
          delete data.outputPath;
          stdout.write(data.source);
        }
        callback(data);
      }
    });
  }
}

/*----------------------------------------------------------------------------*/

// Export `build`.
if (!isBin) {
  module.exports = build;
}
// Handle invoking `build` by the command-line.
else if (_.size(process.argv) > 2) {
  build(process.argv.slice(2));
}
